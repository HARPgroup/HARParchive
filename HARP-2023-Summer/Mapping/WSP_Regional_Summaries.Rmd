---
title: "WSP Regional Summaries"
author: "HARP Analysts"
date: "`r Sys.Date()`"
geometry: margin=1cm #margins for pdf
#overridden by output_format in render command 
output: 
  word_document:
    toc: true
    number_sections: true

#Here is the main editable part of the rmd, planners should adjust parameters as they see fit for their goals, see README documentation for more details on each parameter
#Can edit here or in a render command 
## More params used during development and testing for user-control -- will be consolidated  
params: 

  origin: ["Roanoake_1"] #supply either a rivseg, locality, or region name ## JL7_7070_0001
  origin_type: ["region"] #basin, locality, or region
  featr_type: ["facility"] #source or facility
  
  featrs_file: "C:/HARP/Exports/Roanoke_1_featrs_sf.csv"
  featrs_file_map_bubble_column: ["five_yr_avg"] #runid & metric
  featrs_file_table_column: ["runid_11_wd_mgd","runid_13_wd_mgd","five_yr_avg","wsp2020_2040_mgy"]

  rsegs_file: "C:/HARP/Exports/Roanoke_1_rsegs_sf.csv"
  rivseg_metric: ["l30_Qout", "l90_Qout"] #right now these arent exact column names in the resegs_file
  run_set: ['wsp_2020_2040'] # new method of specifying river metric maps and tables
  runid_list: ["runid_11", "runid_13"] #list of runids used for facil and rseg data

  # aesthetic changes
  crs_default: 4326 #default coordinate system 
  map_style: ["custom"] #determining map aesthetics like colors, fonts, font sizes
  bbox_type: ["auto"] #either 'auto' or 'vahydro'. vahydro map type only functional for riv.segments 
  show_map: TRUE #either TRUE or FALSE
---

```{r setup, include=FALSE, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#ensure all packages and dependencies are installed prior to running 
library(data.table)
library(hydrotools)
library(mgsub)
library(sp)
library(sf)
library(nhdplusTools)
library(png)
library(flextable)
library(pandoc)
#tinytex::install_tinytex() #need to run if you don't have tinytex
library(tinytex)

#gather config info to log into vahydro  
basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new(site, rest_uname)
ds$get_token(rest_pw)
```

```{r UserInputs, echo=FALSE}
# reading in the user inputs from params
origin <- params$origin #supply either a rivseg, locality, or region name ## JL7_7070_0001
origin_type <- params$origin_type #basin, locality, or region
featr_type <- params$featr_type #source or facility

featrs_file <- params$featrs_file
featrs_file_map_bubble_column <- params$featrs_file_map_bubble_column
featrs_file_table_column <- params$featrs_file_table_column

rsegs_file <- params$rsegs_file
run_set <- params$run_set
rivseg_metric <- params$rivseg_metric

runid_list <- params$runid_list
crs_default <- params$crs_default
map_style <- params$map_style
bbox_type <- params$bbox_type
show_map <- params$show_map
    
```

```{r Load Functions & Configs, echo=FALSE, warning=FALSE, results='hide'}
# For planners, updated when changes are merged to master
# Make sure github location in config file is properly set 
github_base_uri <- "https://raw.githubusercontent.com/HARPgroup"
github_uri <- paste0(github_base_uri, "/HARParchive/master")
if (!exists("HARParchive_location")){
  HARParchive_location <- "https://raw.githubusercontent.com/HARPgroup/HARParchive/master"}
  
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fns_spatial.R")) #load functions for dealing with spatial data
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fns_mapgen.R")) #load mapping function
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fn_tablegen.R")) #load table function
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fn_labelprep.R")) #load labeling function
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fn_nhd_labs.R")) #load nhd label function
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Config/mapstyle_config.R")) #load general mapping aesthetics 
#source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Config/rivsegmaps_config.R")) #load rivseg-specific mapping aesthetics
source(paste0(HARParchive_location,"/HARP-2023-Summer/Mapping/Functions/fn_get_memo_nhdplus.R")) #nhd caching

# legend_titling() --> Generate user-understandable legend titles
## Kept up here as a function so that it's easy to add if-statements when user-input options expand
legend_titling <- function(metric, runid_list){
  if (metric=="wd_mgd"){ #titles for wd_mgd
    name <- "Withdrawal"
    unit <- "(MGD)"
    legend_title <- runid_list
    year <- mgsub(runid_list, c("runid_11","runid_13"), c("2020","2040"))
    for (i in 1:length(runid_list)){
      legend_title[i] <- paste(year[i],name,unit,sep="\n")
    }
  } else if (metric=="fiveyr_avg_mgy"){ #this metric isn't associated w a runid
    name <- "5-yr Avg Use"
    unit <- "(MGY)"
    legend_title<- paste(name,unit,sep="\n")
  } else {
    legend_title<- paste(metric)
  }
  return(legend_title)
}

```

```{r data_configuration, echo=FALSE, warning=FALSE, results='hide'}
# reading in the user inputs from params
for(i in 1:length(params)){
  assign(names(params[i]), params[[i]])
}
generate_rmetrics = TRUE
run_config = NULL
if (!is.null(params$run_set)) {
  run_config <- run_sets[[run_set]]
} 
# *****************************************************
# Insure Backward Compatibility With rivseg_metric input
# *****************************************************
# need to load or create nested array riverseg_metrics
# this is deprecated and support will go away 
# because it involves guessing what the column names are
if (is.null(run_config)) {
  run_config = list(riverseg_metrics=list())
  n = 0
  for (j in rivseg_metric) {
    for (i in 2:length(runid_list)) {
      n = n + 1
      run_config$riverseg_metrics[[n]] = list(metric = j, column_name = paste("percentDiff", j,runid_list[1],runid_list[i],sep="_"))
    }
  }
} else {
  # we got a valid run_config so load riverseg_metrics AND generate rivseg_metric
  rivseg_metric = c()
  
  for (j in 1:length(run_config$riverseg_metrics)) {
    rivseg_metric[j] = run_config$riverseg_metrics[[j]]$metric
  }
}

```

```{r Load Data, echo=FALSE, warning=FALSE, results='hide'}
regions_file <- paste0(HARParchive_location, '/HARP-2023-Summer/Mapping/Data/regions_sf.csv')
counties_file <- paste0(HARParchive_location, '/HARP-2023-Summer/Mapping/Data/counties_sf.csv')
cities_file <- paste0(HARParchive_location, '/HARP-2023-Summer/Mapping/Data/cities.csv')
roads_file <- paste0(HARParchive_location, '/HARP-2023-Summer/Mapping/Data/roads_sf.csv')

facils <- sf::st_as_sf(read.csv(featrs_file), wkt = "WKT", crs=crs_default, remove=FALSE)
rsegs <- sf::st_as_sf(read.csv(rsegs_file), wkt = "WKT", crs=crs_default, remove=FALSE)
counties <- sf::st_as_sf(read.csv(counties_file), wkt = "WKT", crs=crs_default, remove=FALSE)
regions <- sf::st_as_sf(read.csv(regions_file), wkt = "WKT", crs=crs_default, remove=FALSE)
cities <- fread(cities_file) #no sf geom in cities file; st_read converts columns to character (need coords to be numeric)
roads <- sf::st_as_sf(read.csv(roads_file), wkt = "WKT", crs=crs_default, remove=FALSE)
regions <- sf::st_as_sf(read.csv(regions_file), wkt = "WKT", crs=crs_default, remove=FALSE)

```

```{r Bbox, echo=FALSE, message=FALSE, warning=FALSE}
if(bbox_type == "vahydro") { #retrieve bbox from vahydro property if desired
#note: only operational for river segments/basins
  for (i in 1:nrow(rsegs)){ #not sure why we're looping through these if we're only saving the last one
    bbox <- ds$get_prop(config=list( #get bbox properties
                        featureid= RomProperty$new(ds,list( #get extent property pid
                                      propname="extent",
                                      entity_type="dh_properties",
                                      featureid= RomProperty$new(ds,list( #get map property pid
                                                    varkey="map", 
                                                    entity_type="dh_feature",
                                                    featureid= rsegs$hydroid[i]
                                                    ),TRUE)$pid #map pid
                                      ),TRUE)$pid, #extent pid
                        entity_type='dh_properties'))
    bbox <- data.frame(X=extent[1:2,4], Y=extent[3:4,4])
    bbox <- st_buffer(st_as_sf(extent_df, coords=c("X","Y"), crs=crs_default), dist=0.15) #original : dist=0.05
    bbox <- st_bbox(bbox)
  }
} else { #auto bbox. should always be around the basins intersecting region of interest
  sf_use_s2(FALSE) # switch off Spherical geometry
  bbox <- st_buffer(st_as_sfc(st_bbox(rsegs)), .02) #slightly past basin
  bbox <- st_bbox(bbox)
}
```

```{r Get NHD in Bbox, echo=FALSE, message=FALSE, warning=FALSE}
# source(paste0(github_location,"/HARParchive/HARP-2023-Summer/fn_nhd_labs.R"),local = TRUE) #load nhd label function

# NHD data within the bbox
if (show_map == TRUE) {
  st_crs(bbox) <- crs_default
  #if (exists("memo_plot_nhdplus")){
    nhd  <- memo_plot_nhdplus(bbox = bbox, actually_plot = FALSE)
  #} else {
   # nhd  <- plot_nhdplus(bbox = bbox, actually_plot = FALSE)
  #}
  nhdlabs <- fn_nhd_labs(data=nhd)
}
```

```{r Filter NHD, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
# Was trying to remove the need for the fn_nhd_labs() since that basically just filters the nhd data now, but ran into some errors...

if (show_map == TRUE) {
  # First organize flowline data with major rivers/streams
  #major rivs = orders 5 & 6; streams = order 4
  flow <- nhd$flowline[nhd$flowline$gnis_name!=' ' & #name!=blank & order 4, 5, or 6
                          (nhd$flowline$StreamOrde==6 | nhd$flowline$StreamOrde==5 | nhd$flowline$StreamOrde==4),]
  flow <- flow[order(-flow$StreamOrde, flow$gnis_name, -flow$LENGTHKM) & !duplicated(flow$gnis_name),] #no duplicate names; prioritize higher order names and then the longest segment of each duplicate
  flow$gnis_name <- mgsub(flow$gnis_name, # shorten long names
                          c('North Fork','South Fork','East Fork','West Fork','Middle Fork'), #pattern
                          c('NF','SF','EF','WF','MF')) #replacement
  flow$StreamOrde <- mgsub(flow$StreamOrde, c(4,5,6), c("stream","majorRiver","majorRiver"))
  colnames(flow) <- gsub("StreamOrde", "class", colnames(flow))
  
  # Now do the same for the water bodies
  wtbd <- rbind(nhd$network_wtbd, nhd$off_network_wtbd)
  statemt <- paste("SELECT *,
                    CASE WHEN lakevolume BETWEEN",quantile(wtbd$lakevolume, 0.0,T),"AND",quantile(wtbd$lakevolume, 0.5,T),
                      "THEN 'wtbd_sm'
                    WHEN lakevolume BETWEEN",quantile(wtbd$lakevolume, 0.5,T),"AND",quantile(wtbd$lakevolume, 0.75,T),
                      "THEN 'wtbd_med'
                    WHEN lakevolume >",quantile(wtbd$lakevolume, 0.75,T),
                      "THEN 'wtbd_lg'
                    ELSE 'unclassified'
                    END as class
                    FROM wtbd
                    WHERE (gnis_name != ' ' AND gnis_name != 'Noname' AND gnis_name IS NOT NULL)
                   ", sep=" ")
  wtbd <- fn_sqldf_sf(statemt, "wtbd")
  
  # enseure both datasets have same crs prior to rbind()
  st_crs(flow) <- crs_default
  st_crs(wtbd) <- crs_default 
  nhd2 <- rbind( flow[,c("gnis_name", "class", "geometry")], wtbd[,c("gnis_name", "class", "geometry")] )
}
```

```{r Prep Text Labels, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
if (show_map == TRUE) {
  rm(maplabs)
  maplabs <- fn_labelprep(data=list(counties, cities, roads, nhdlabs), classes=c("county","city","road","nhd"))
}
```

# Region

## Framing Text:

Including how to use this doc per regulatory requirement. Include note that water is limited for your locality due to what was withdrawn upstream, and what needs to be left for downstream users. Ex. for Drought (reg section XXX), refer to summary document Drought section L90 maps.

## State Plan 2020 demand - State Plan 2040 demand:

### Map:

```{r Create Map 1, echo=FALSE, message=FALSE, warning=FALSE}
#----Map 1----
# Legend Bins
facils <- facils[,colSums(is.na(facils))<nrow(facils)] #for extra long & lat columns full of NAs
#st_write(facils, paste0(export_path,"33_facils_sf.csv"), layer_options = "GEOMETRY=AS_WKT")

#create human-readable title based on origin & type
if (origin_type == "basin") {
  title_main <- (paste("Basin Upstream of", rsegs$name[rsegs$riverseg==origin] , origin, sep=" "))
} else if (origin_type == "locality") {
  title_main <- paste0(counties[["name"]][counties[["dh_fips"]]==origin]," Locality")
} else if (origin_type == "region") {
  origin_readable <- gsub("([a-z])([A-Z])","\\1 \\2", origin)
  title_main <- paste0( gsub("_", " ", origin_readable) , " Region")
  
} 

if (show_map == TRUE) {
  for (i in 1:length(featrs_file_map_bubble_column)) { #execute for each metric in featrs_file_map_bubble_column param 
    #legend_title <- paste0(featrs_file_map_bubble_column[i])
    #legend_title <- legend_titling(featrs_file_map_bubble_column[i], runid_list)
    legend_title <- new_metric_name[grep(featrs_file_map_bubble_column[i], read_metric_name)]
    
    #add column of NAs when no metric col exists, when no facilities with the desired metric exist in the extent
    if ((featrs_file_map_bubble_column[i] %in% colnames(facils)) == FALSE) {
      facils[featrs_file_map_bubble_column[i]] <- NA
      mapMessage <- TRUE #for returning message to user if map is empty
    } else { mapMessage <- FALSE  }
    #Ordering & numbering data by the metric to be mapped 
     facils <- fn_sqldf_sf(paste0( #ordering the data using sqldf 
     "SELECT facils.*  
     FROM facils
     ORDER BY", ' ', featrs_file_map_bubble_column[i], ' ', "DESC"), #ordering by the metric of interest, descending 
     "facils")
    facils$NUM <- seq(1, nrow(facils))
    
    metric_unit <- substr(featrs_file_map_bubble_column[i], nchar(featrs_file_map_bubble_column[i]) - 2, 
                          nchar(featrs_file_map_bubble_column[i]))  #get metric unit from last 3 characters of metric 
    if (metric_unit == "mgd") { #different ranges for mgd and mgy
      div <- wd_mgd
    } else if (metric_unit == "mgy") {
      div <- wd_mgy
    } else {
      div <- wd_mgy #default units of million gallons per day 
    }
    
    mp_layer_sql <- paste('SELECT *, ',featrs_file_map_bubble_column[i],' AS demand_metric
          FROM facils' , sep="") #Renaming metric of interest for generalized sorting into bins
    mp_layer <- fn_sqldf_sf(mp_layer_sql, "facils")
    bins = as.data.frame(div)
    bins$classid <- index(bins)
    names(bins) <- c("val", "bin")
  
    entity_classes <- fn_sqldf_sf( #sorting the data into bins based on their range 
        "select a.NUM, max(b.bin) as bin
        from mp_layer as a 
        left outer join bins as b 
        on (a.demand_metric >= b.val) 
        group by a.NUM" , "mp_layer")
    
    mp_layer <- fn_sqldf_sf( #joining the bins with the metric data 
        "select a.*, b.bin 
        from mp_layer as a 
        left outer join entity_classes as b 
        on a.NUM = b.NUM " , "mp_layer")
  
    mp_layer$bin[is.na(mp_layer$bin)] <- "X" # replacing NA values in bin column
    names(mp_layer)[names(mp_layer) == 'demand_metric'] <- featrs_file_map_bubble_column[i] #change column name back to the specific metric
    mp_layer <- mp_layer[, !duplicated(colnames(mp_layer))] #remove duplicated columns
    mp_layer <- fn_centroid_coords(mp_layer)
    
    rsegs <- fn_centroid_coords(data = rsegs, geom_col = "geometry", crs = crs_default)
    
    # colname <- paste0(featrs_file_map_bubble_column[i]) #define title here for mapping so each map has diff metric title, pass into function
    # 
    # ## Create title for the map
    #   #first create label for metric
    # if (featrs_file_map_bubble_column[i]=="five_yr_avg"){
    #   maplabel <- gsub("five_yr_avg", "5 Year Avg (MGY)", colname)
    # } else if (featrs_file_map_bubble_column[i]=="wd_mgd"){
    #   maplabel <- gsub("wd_mgd", "Withdraw (MGD)", colname)
    # } else if (featrs_file_map_bubble_column[i]=="gw_demand_mgd"){
    #   maplabel <- gsub("gw_demand_mgd", 'Ground Water Demand (MGD)', colname)
    # } else if (featrs_file_map_bubble_column[i]=="ps_mgd"){
    #   maplabel <- gsub("ps_mgd", "Point Source (MGD)", colname)
    # } else {
    #   maplabel <- colname
    # }
    ##instead:
    maplabel <- new_metric_name[grep(featrs_file_map_bubble_column[i], read_metric_name)]
    

    #create map title by combining label and title
    maptitle <- paste0(title_main, ", ", maplabel)
    map_style_set <- styles[[map_style]]
    
    map <- fn_mapgen(bbox, crs_default, metric_unit, mp_layer, featr_type, 
                     maptitle, mapnum=1, rseg_leg_title=NULL, map_server, base_layer, 
                     maplabs, nhd, roads, rsegs, map_style_set)
                    
    #assign map to environment
    assign(paste0('map', i), map, envir = globalenv())
  }

  ##### Mapping Errors:
    # Error in if (distance > 300) { : missing value where TRUE/FALSE needed
    # Solution: this indicates the bbox is not in the format needed by the function. 
      # Regenerate the bbox and make sure it is of class bbox and has names xmin, xmax, etc.
  
    # Error in rbind(deparse.level, ...) : numbers of columns of arguments do not match
    # Solution: maplabs object needs to be removed and re-generated
  #####

  # Save map as png
  map_name <- origin
  
  #add sources or facils to name based on type 
  if (featr_type == "source") {
    map_name <- paste0(map_name, '_sources')
  } else if (featr_type == "facility") {
    map_name <- paste0(map_name, '_facils')
  }
  
  # Saving map(s) as a png
  # export_path set in config for analysts, set in console if nonexistent to location where map will be exported 
  mapfilename <- character() #empty character var, not a list
  for (i in 1:length(featrs_file_map_bubble_column)) {
    mapfilename[i] <- paste(export_path, map_name, "_", featrs_file_map_bubble_column[i], ".png", sep="")
    mapf <- get(paste0('map',i))
    ggsave(
      filename = mapfilename[i],
      plot = mapf,
      width = 25,
      height = 20)
  } 
  facils_nogeom <- st_drop_geometry(facils)

} else { #if we don't want to show maps 
  #still need to sort & number data for table even if not mapping 
  #default when not mapping will be sorting table by first entry of table columns 
  facils_nogeom <- st_drop_geometry(facils)
  class(facils_nogeom[,featrs_file_table_column[1]]) <- "numeric"
  facils <- fn_sqldf_sf(paste0( #ordering the data using sqldf 
     "SELECT facils_nogeom.*  
     FROM facils_nogeom
     ORDER BY", ' ', featrs_file_table_column[1], ' ', "DESC")) #ordering by the metric of interest, descending 
  facils_nogeom$NUM <- seq(1, nrow(facils))
}

```

```{r View Map 1, echo=FALSE, out.width = '100%', out.height='100%', message=TRUE,eval = show_map}
knitr::include_graphics(mapfilename) #display map(s) PNG -- not functional inside loop
# if (mapMessage) {
#   message("The metric requested does not exist for this map.")
#   message("Check your syntax/spelling. If correct, then this data has not been measured/modeled")
# }

messages <- data.frame(pertaining_to=character(0), message=character(0), 
                        var_name=character(0) )
if (mapMessage) {
  messages <- rbind(messages,
                    data.frame(pertaining_to= "Map 1",
                              message=paste0("The metric requested does not exist for this map.\nCheck your syntax/spelling. If correct, then this data has not been measured/modeled."),
                       var_name= "mapMessage"
                       )
                    )
}

```

```{r Create Table 1, echo=FALSE, message=FALSE, warning=FALSE}
#facils_nogeom created if show_map = FALSE
if (show_map == FALSE) {
  facils_table <- facils_nogeom
} else {
  facils_table <- st_drop_geometry(facils)
}

names(facils_table)[names(facils_table) == 'propname'] <- 'Facility' #if propname column exists rename to Facility
#facils_table$within$hydroid <- as.numeric(gsub(",", "", facils_table$within$hydroid, fixed = TRUE))
#create initial table
table <- data.frame(
  Number= facils_table$NUM,
  Facility=facils_table$facility,
  HydroID = facils_table$Facility_hydroid, 
  GWFrac = facils_table$gw_frac)

#for source type only add mp name and source type to table
if (featr_type=="source"){
  table$Source = facils_table$MP_Name  
  table$Source_Type = facils_table$Source_Type
}

table$Locality = facils_table$Locality
#write.csv(table, paste0(export_path,"40_table.csv"))

#add rivseg names
for(i in 1:nrow(table)){ 
  loc_rivseg <- (rsegs[grep(facils_table$riverseg[i], rsegs$riverseg),]) #find rivseg in segs and compare to facils_table to add name
  if (nrow(loc_rivseg) != 0) {
    table$`River Segment Name`[i] <- loc_rivseg$name
  } else { # if no matching row was found for the riverseg ID, leave blank but don't break
    table$`River Segment Name`[i] <- ""
    }
}

table$`River Segment ID`= facils_table$riverseg #add rivseg ID

table$`Permitted Capacity` <- facils_table$Permit_Limit_MGY #add permitted capacity to table 

for (i in 1:length(featrs_file_table_column)){
  #metric col of interest may not exist if none were found in extent: don't break if this is the case
  if (featrs_file_table_column[i] %in% colnames(facils_table)) {
  #adding requested columns to table
    table[,featrs_file_table_column[i]] <- round(as.numeric(facils_table[,featrs_file_table_column[i]]), digits = 2)
  }
}

table <- table[,colSums(is.na(table))<nrow(table)] #remove columns with all NAs, added to df for mapping as placeholders 

#compare requested table columns with those that actually exist 
novals <- data.frame(metric=character())
for (i in 1:length(featrs_file_table_column)) {
  if (!featrs_file_table_column[i] %in% names(table)) {
    novals[i,] <- featrs_file_table_column[i]
  }
}
#for returning message if metric table columns were missing 
if (nrow(novals > 0)) {
  tableMessage <- TRUE
} else { tableMessage <- FALSE }

# Rename columns & create flextable
#names(table)[names(table) == 'Source_Type'] <- 'Source Type'

for (i in 1:length(featrs_file_table_column)) {
  for (x in 1:nrow(metric_names)){
    if (featrs_file_table_column[i]==metric_names$read_metric_name[x])
    {
      names(table)[names(table)==featrs_file_table_column[i]] <- metric_names$new_metric_name[x]
    }
    else
    {
      next
    }
  }
}

names(table)[names(table) == 'five_yr_avg'] <- '5-yr Avg Use (mgy)'
names(table) <- mgsub(names(table), pattern="_", replacement=" ") #formatting for flextable headers, line breaks happen at spaces not underscores


ft1 <- fn_tablegen(featr_type = "facility", table = table, 
                   columns = "all", alignment = "left", 
                   origin_type = origin_type, metric = rivseg_metric[i], 
                   origin = origin, tabletitle = title_main, num = "1.1" ) #execute flextable function
ft1 <- add_header_lines(ft1, values= "Table 1.1") #add subtite
ft1 <- width(ft1, j= 'River Segment ID', width = 1) #making sure rseg ID isn't cut off in facil/source tables

```

###Narrative note: Narrative including note that facilities constructed after initial plan submission are not show in 2020 scenario

### Table:

```{r View Table 1, echo=FALSE, out.width='100%', message=TRUE}
# if (tableMessage == TRUE) {
#   message("Missing column indicates the metric requested does not exist for this table")
# }
if (tableMessage) {
 messages <- rbind(messages,
                      data.frame(pertaining_to= "Table 1",
                       message=paste0("Missing column indicates the metric requested does not exist for this table."), var_name= "tableMessage")
                      )
}

ft1 #display flextable
```

## 2020/2040 Demand Scenarios Through Drought Metrics: L90 -- 7Q10:

### Map:

```{r Create Map 2, echo=FALSE, message=FALSE, warning=FALSE}
#----Map 2----
  map_objects = list()
  rivmapfilename <- character() #empty character var, not a list, to store map names
  for (i in 1:length(run_config$riverseg_metrics)){ #something going wrong in rsegs df within this loop 
     
     display_map <- run_config$riverseg_metrics[[i]]$show_map
     if (is.null(display_map)) { display_map = FALSE}
     if (display_map == TRUE) {
      display_metric <- run_config$riverseg_metrics[[i]]$metric
      display_column <- run_config$riverseg_metrics[[i]]$column_name
      display_title <- run_config$riverseg_metrics[[i]]$run_label
    
     # rseg_leg_title <- legend_titling(display_metric, runid_list)

      rivmapmetric <- paste0(display_metric) #define title here for mapping so each map has diff metric title, pass into function
    
    if (display_metric=="l30_Qout"){
        rivmaplabel <- gsub("l30_Qout", "Lowest 30 Day Flow", rivmapmetric)
    } else if (display_metric=="l90_Qout"){
        rivmaplabel <- gsub("l90_Qout", "Lowest 90 Day Flow", rivmapmetric)
    } else {
        rivmaplabel <- rivmapmetric
    }
  
    rivmaptitle <- paste0(display_title, ", ", rivmaplabel)
    
    rsegs <- rsegs[ , !names(rsegs) %in% c("pct_diff", "bin")]
    #st_write(rsegs, paste0(export_path,"45_rsegs_sf_",rseg_leg_title,".csv"), layer_options = "GEOMETRY=AS_WKT")
    
  #### Problem with rsegs df happens here 
    # rseg_sql <- paste('SELECT *, ','percentDiff','_',display_metric,' AS pct_diff 
    #       FROM rsegs' , sep="") #Renaming metric of interest for generalized sorting into bins
    # 
    # rsegs <- fn_sqldf_sf(rseg_sql,"rsegs")
    #st_write(rsegs, paste0(export_path,"46_rsegs_sf_",rseg_leg_title,".csv"), layer_options = "GEOMETRY=AS_WKT")
  ####
    
    ##Work-around to problem above: change column name
    rseg_geom <- rsegs$geometry #save geometry before dropping
    rsegs <- st_drop_geometry(rsegs)
    bins = as.data.frame(rivseg_pct_vect) #rivseg_pct_vect set in config
    bins$classid <- index(bins)
    names(bins) <- c("val", "bin")
    #write.csv(bins, paste0(export_path,"47_bins_",rseg_leg_title,".csv"))
  
    rivseg_classes <- sqldf( #sorting the data into bins based on their range 
      paste0("select a.riverseg, min(b.bin) as bin
      from rsegs as a 
      left outer join bins as b 
      on (a.", display_column," <= b.val) 
      group by a.riverseg" )
    )
    #write.csv(rivseg_classes, paste0(export_path,"48_rivseg_classes_",rseg_leg_title,".csv"))
    
  ## sqldf error here about raw vectors  
    # rsegs <- fn_sqldf_sf( #joining the bins with the metric data 
    #   "select a.*, b.bin 
    #   from rsegs as a 
    #   left outer join rivseg_classes as b 
    #   on a.riverseg = b.riverseg " , "rsegs")
    # st_write(rsegs, paste0(export_path,"49_rsegs_sf_",rseg_leg_title,".csv"), layer_options = "GEOMETRY=AS_WKT")
    
    rsegs <- sqldf( #joining the bins with the metric data 
      "select a.*, b.bin 
      from rsegs as a 
      left outer join rivseg_classes as b 
      on a.riverseg = b.riverseg " , "rsegs") 
    
    rsegs_sf <- st_as_sf(rsegs, wkt = 'WKT') #this function removes WKT col, so create new df to prevent loop error
    st_crs(rsegs_sf) <- crs_default
  
    ##Mapping function
    map_rivseg <- fn_mapgen(bbox, crs_default, metric_unit, mp_layer, featr_type, 
                       maptitle = rivmaptitle, mapnum=2, #rseg_leg_title
                       display_title, map_server, base_layer, 
                       maplabs, nhd, roads, rsegs=rsegs_sf, map_style_set)
    map_objects[[i]] <- map_rivseg
    #assign map to environment
    assign(paste0('map_rivseg', i), map_rivseg, envir = globalenv())
  
    ## Save rivseg map
    rivmapfilename[i] <- paste(export_path, map_name, "_", display_column, ".png", sep="")
    ggsave(
      filename = rivmapfilename[i],
      plot = map_rivseg,
      width = 25,
      height = 20)
     } else {
      print("No map created for this metric")
    }
  }
```

```{r Display Map 2, out.width = '100%', out.height='100%', echo=FALSE, eval=FALSE}
if (show_map == TRUE) {
  knitr::include_graphics(rivmapfilename)
}
```


```{r Create Table 2 UPDATED, echo=FALSE, message=FALSE, warning=FALSE}

#NEW TABLE WITH RUNSET

rivTables <- list() #to store dataframes for each drought metric
rseg_no_geom <- st_drop_geometry(rsegs) #copy of rsegs 

  # base info
for (k in 1:length(run_config$riverseg_metrics)){
  data_set <- run_config$riverseg_metrics[[k]]$data_set
  table_cols <- unlist(run_config$riverseg_metrics[[k]]$tables_cols)
  display_column <- run_config$riverseg_metrics[[k]]$column_name
  
  # test for existence of data_set variable (i.e. data_set = "rseg_no_geom", or data_set = "facils_nogeom"
  if (exists(data_set)) {
    rseg_display <- get(data_set)
    
    display_metric <- run_config$riverseg_metrics[[k]]$metric
    display_title <- run_config$riverseg_metrics[[k]]$run_label
    
    #metrics, to be suppressed later?
    rseg_display$Metric <- display_metric 

    #assemble our table, with the columns in order defined by table_cols
    # cols present
    # Megan: can you insert into error messages if cols_present <> table_cols?
    cols_present <- table_cols[which(table_cols %in% names(rseg_display))]
    message_nonexisting_cols <- any(table_cols %in% cols_present) # Megan: done!
    rseg_display <- rseg_display[cols_present] #need to make sure table_cols and column_name properly done in mapstyle_config or will get error here

    
    #na messages 
    
    nacols <- colSums(is.na(rseg_display)) == nrow(rseg_display)
    tablemessage2 <- any(nacols) 
    
    #sorting 
    sort_decreasing <- run_config$riverseg_metrics[[k]]$sort_decreasing 
    rivTables[[k]] <- rseg_display[order(as.vector(rseg_display[,display_column]), decreasing=sort_decreasing),] 
    
    
    #fill blanks with NA
    rivTables[[k]][rivTables[[k]] == ''] <- NA
    
    
    #defining titles 
    rivtablemetric <- paste0(display_metric) #define title here for mapping so each map has diff metric title, pass into function
    

    rivtablenum <- k + 1 #for heading numbering, use 1 + rivtablenum since we already printed a table
  
    ft2 <- fn_tablegen(featr_type = FALSE, table = rivTables[[k]],
                       columns = "all", alignment = "left", 
                       metric = display_metric, origin_type = origin_type,  
                       origin = origin , tabletitle = display_title,
                       num=rivtablenum, highlight_col = display_column, highlight_limit = -10) #flextable function 
    
    assign(paste0('table', k), ft2, envir = globalenv())
  
  display_metric <- run_config$riverseg_metrics[[k]]$metric
  display_title <- run_config$riverseg_metrics[[k]]$run_label

  #metrics, to be suppressed later?
  rseg_display$Metric <- display_metric 

  #assemble our table, with the columns in order defined by table_cols
  rseg_display <- rseg_display[cols_present] #need to make sure table_cols and column_name properly done in mapstyle_config or will get error here
  
  #na messages 
   nacols <- data.frame(colSums(is.na(rseg_display)) == nrow(rseg_display)) #dataframe of which columns are all na or not
   tablemessage2 <- any(nacols)
  
  #sorting 
  sort_decreasing <- run_config$riverseg_metrics[[k]]$sort_decreasing 
  rivTables[[k]] <- rseg_display[order(as.vector(rseg_display[,display_column]), decreasing=sort_decreasing),] 
  
  
  #fill blanks with NA
  rivTables[[k]][rivTables[[k]] == ''] <- NA
  
  
  #defining titles 
  rivtablemetric <- paste0(display_metric) #define title here for mapping so each map has diff metric title, pass into function
  
  # this chunk is not in use at the moment, based on titles being done in config 
  if (display_metric=="l30_Qout"){
      rivtablelabel <- gsub("l30_Qout", "Lowest 30 Day Flow", rivtablemetric)
    } else if (display_metric=="l90_Qout"){
      rivtablelabel <- gsub("l90_Qout", "Lowest 90 Day Flow", rivtablemetric)
    #print(get(paste0('table', k))) #doesn't work to display flextables in loop on rendering 
  } else {
    message(paste("The requested data_set,", data_set,"is not defined. Please adjust settings in config file"))
  }
  }
}
```

### Table:

```{r View Table 2, out.width = '100%', out.height='100%', results='asis', echo=FALSE, eval=FALSE}
#result = 'asis' necessary 
# if (tablemessage2==TRUE) {
#   message("A column in the table is completely NA values, 
#           likely meaning the metric requested is not modeled for this data
#           or the segments are all tidal")
# }
if(message_nonexisting_cols){
  messages <- rbind(messages,
                      data.frame(pertaining_to= "Table 2",
                       message=paste0("Not all of the requested columns could be found in the present data. Check mapstyle_config.R and Dataframe_Generator.R render"), var_name= "message_nonexisting_cols")
                      )
}
if(tablemessage2){
  messages <- rbind(messages,
                      data.frame(pertaining_to= "Table 2",
                       message=paste0("A column in the table is completely NA values, 
          likely meaning the metric requested is not modeled for this data,
          or the segments are all tidal."), var_name= "tablemessage2")
                      )
}

for (k in 1:length(rivseg_metric)){
  cat(knitr::knit_print(get(paste0('table', k))))
  cat("\n\n\\pagebreak\n")
  #cat(flextable::flextable_to_rmd(get(paste0('table', k))))
}

#note: doesn't display readable flextable within Rstudio but does upon render
```

### Display Map and Table: 
```{r View Rivseg Maps and Tables, out.width = '100%', out.height='100%', results='asis', echo=FALSE}
for (k in 1:length(run_config$riverseg_metrics)){
  #map
  show_map = run_config$riverseg_metrics[[k]]$show_map
  if (show_map == TRUE) {
    #fig_md = knitr::include_graphics(rivmapfilename)
    fig_md = paste(paste0("![](",rivmapfilename[k],")"),"\n")
  } else {
    fig_md = ''
  }
    #table
    if (tablemessage2==TRUE) {
      message("A column in the table is completely NA values, 
          likely meaning the metric requested is not modeled for this data
          or the segments are all tidal")
    }
    cat(fig_md)
    cat(knitr::knit_print(get(paste0('table', k))))
    cat("\n\n\\pagebreak\n")
  }
```
### Narrative note:

Narrative summarizing highlights from maps/tables

## Climate: State Plan Dry climate scenario - Climate differential scenario

### Map

### Table

### Narrative Note:

Narrative summarizing highlights from maps/tables

## CU: Overall Change in Flow from State Plan

### Map

### Table

### Narrative Note:

# Locality Focus:

repeat above for localities

# Region Appendix:

```{r Generate Errors Summary, echo=FALSE}
#if there are any mapping errors or other messages to the user, output a separate file containing them
allmaps <- grep("gg", eapply(.GlobalEnv, class), value=TRUE)
allmaps <- mget(names(allmaps), .GlobalEnv, mode = "list")
#allmaps = map_objects
maperrors <- data.frame(maptitle=character(0), errors=character(0), 
                        mapnum=character(0), var_name=character(0) )
for(i in 1:length(allmaps)){
  if(!is.null(allmaps[[i]][["errors"]])){
    if (is.null(allmaps[[i]][["mapnum"]])) {
      allmaps[[i]][["mapnum"]] = 2
    }
    maperrors <- rbind(maperrors,
                       data.frame(maptitle = allmaps[[i]][["labels"]][["title"]],
                                  errors = allmaps[[i]][["errors"]],
                                  mapnum = allmaps[[i]][["mapnum"]],
                                  var_name = names(allmaps[i])
                                  )
                       )
  }
}

if(nrow(maperrors)==0){
  maperrors <- rbind(maperrors, data.frame(maptitle="none", errors="none", 
                        mapnum="none", var_name="none"))
}
tbl_maperrors <- mk_par(x = flextable(maperrors), j = c("maptitle","mapnum","var_name"),
                        i = ~ duplicated(maperrors$var_name),
                        value = as_paragraph('')
                        )
tbl_maperrors <- set_table_properties(tbl_maperrors, layout = "autofit")


#other messages:
if(nrow(messages)==0){
  messages <- rbind(messages,
                      data.frame(pertaining_to="none",
                       message="none", var_name="none")
                      )
}
tbl_usermessages <- flextable(messages)
tbl_usermessages <- set_table_properties(tbl_usermessages, layout = "autofit")

#output to .html:
save_as_html("Messages to User:" = tbl_usermessages, "Errors With Mapping:" = tbl_maperrors,
    path = paste0(export_path, origin, "_ErrorsAndMessages.html")
    )
    
# test first, as some can't write these html tables without error
#btable <- flextable(as.data.frame(c(1,2,3)))
#twrite_test <- try(save_as_html(btable,path="test.html"), silent=TRUE)
#if (!class(twrite_test) == "try-error") {
#  if(exists("tbl_maperrors") & exists("tbl_usermessages")){
#    save_as_html(
#      "Messages to User:" = tbl_usermessages, "Errors With Mapping:" = tbl_maperrors,
#      path = paste0(export_path, origin, "_ErrorsAndMessages.html")
#    )
#  }
#  if(exists("tbl_maperrors") & !exists("tbl_usermessages")){
#    save_as_html(
#      "Errors With Mapping:" = tbl_maperrors,
#      path = paste0(export_path, origin, "_ErrorsAndMessages.html")
#    )
#  }
#  if(!exists("tbl_maperrors") & exists("tbl_usermessages")){
#    save_as_html(
#      "Messages to User:" = tbl_usermessages,
#      path = paste0(export_path, origin, "_ErrorsAndMessages.html")
#    )
#  }
#}
```
