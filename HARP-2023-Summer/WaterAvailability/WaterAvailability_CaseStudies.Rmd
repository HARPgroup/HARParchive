---
date: "`r Sys.Date()`"
author: "Glenn Campagna"
title: "officedown template"
output: 
  officedown::rdocx_document:
    mapstyles:
      Normal: ['First Paragraph']
      
params: 
  impoundment_list: ["Lake Manassas", "Lake Moomaw", "Lake Chesdin", "Lake Anna", "Carvins Cove", "Jennings Randolph Lake"]
  demand_scenario: ["runid_11"] 
  baseline_scenario: ["runid_0"] 
  mif_coef: [0.9]
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.cap = TRUE)

library(data.table)
library(hydrotools)
library(sqldf)
library(flextable)
library(officedown)
library(officer)

basepath='/var/www/R'
source('/var/www/R/config.R') 
ds <- RomDataSource$new(site, rest_uname)
ds$get_token(rest_pw)

options(scipen = 999) #disable scientific notation

#assign params
for(i in 1:length(params)){
  assign(names(params[i]), params[[i]])
}

#get numeric element of demand scenario runid to use in fn_get_runfile
runid_dem = as.numeric(gsub(".*?([0-9]+).*", "\\1", demand_scenario))   

#flextable default formatting
set_flextable_defaults(
  font.size = 8, background.color = "white", 
  na_str = "NA", nan_str = "NA", #padding = 1, 
  table.layout = 'fixed', tabcolsep = 1.5,
  fonts_ignore = T, big.mark = "", decimal.mark= ".") #fonts_ignore applies when knitting as pdf 

#document formatting (came with template)
fp <- fp_par(
  text.align = "center", 
  padding.bottom = 20, padding.top = 120, 
  border.bottom = fp_border())

ft <- fp_text(shading.color='#EFEFEF', bold = TRUE)
```


\newpage

## Table of contents

<!---BLOCK_TOC--->

## List of tables

<!---BLOCK_TOC{seq_id: 'tab'}--->

## List of figures

<!---BLOCK_TOC{seq_id: 'fig'}--->


\newpage

## Sections

<!---BLOCK_MULTICOL_START--->
Column1
`r run_columnbreak()` 
Column2
<!---BLOCK_MULTICOL_STOP{widths: [3,3], space: 0.2, sep: true}--->

# Water Availability Case Studies 


## Case Study Description 
### A case study is a descriptive example of a particular area (ex. a watershed/region) where water availability is calculated. For that example watershed, we can take a detailed look at the individual calculations and resulting values generated.


# Impoundments for case studies:
- Lake Manassas 
- Lake Moomaw
- Lake Chesdin 
- Lake Anna 
- Carvin's Cove 
- Jennings Randolph Lake 


```{r Pull Data, echo = FALSE, message=FALSE, warning=FALSE}
#Get storage metrics 
df_storage <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(demand_scenario, demand_scenario),
  'metric' = c('Smin_L30_mg', 'Smin_L90_mg'),
  'runlabel' = c('SminL30mg_apx','SminL90mg_apx')
)
storage_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_storage, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)

#Get demand scenario metrics used in WA eqn
df_metrics <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(demand_scenario, demand_scenario, demand_scenario),
  'metric' = c('wd_cumulative_mgd', 'l30_Qout', 'l90_Qout'),
  'runlabel' = c('wd_cumulative_mgd', 'l30_Qout_dem', 'l90_Qout_dem')
)
metric_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_metrics, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)

#Get baseline scenario metrics for WA eqn
df_baseline <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(baseline_scenario, baseline_scenario),
  'metric' = c('l90_Qout', 'l30_Qout'),
  'runlabel' = c('l90_Qout_base', 'l30_Qout_base')
)
baseline_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_baseline, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)
```

```{r Smin Calculations, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
storage_data$SminL30mg_nex <- NA #empty columns to hold near exact storage values
storage_data$SminL90mg_nex <- NA

storage_data$min_in_pd30 <- NA #empty columns to hold TRUE/FALSE
storage_data$min_in_pd90 <- NA 

storage_data$outside_pd30 <- NA #empty columns to hold numeric values
storage_data$outside_pd90 <- NA 

for (i in 1:nrow(storage_data)) {
  #Get runfile with timeseries data from VAhydro
  pid <- storage_data$pid[i]

  token = ds$get_token(rest_pw) #needed for elid function
  elid <- om_get_model_elementid(
    base_url = site,
    mid = storage_data$pid[i]
  )
  rm(token)

  dat <- fn_get_runfile(elid, runid_dem, site= omsite,  cached = FALSE) #get timeseries data (read in as zoo)
  mode(dat) <- 'numeric'
  
  #Get model to get object class
  model <- RomProperty$new(ds,list( 
    featureid = storage_data$featureid[i],
    propcode = 'vahydro-1.0'
  ),TRUE)
  
  #Get object class 
  object_class <- RomProperty$new(ds,list( #get vahydro-1.0 model feature from vahydro
    featureid = model$pid,
    propname = 'object_class'
  ),TRUE)  
  
  object_class <- object_class$propcode
  cols <- names(dat)
  
  #Trim runfile
  syear = as.integer(min(dat$year))
  eyear = as.integer(max(dat$year))
  if (syear < (eyear - 2)) {
    sdate <- as.Date(paste0(syear,"-10-01"))
    edate <- as.Date(paste0(eyear,"-09-30"))
  } else {
    sdate <- as.Date(paste0(syear,"-02-01"))
    edate <- as.Date(paste0(eyear,"-12-31"))
  }
  dat <- window(dat, start = sdate, end = edate);
  mode(dat) <- 'numeric' 
  
  #Check if impoundment is active
    #2 ways this is done: im_off and imp_enabled 
    #imp_off used in waterSupplyModelNode and hydroImpoundment
    #imp_enabled used in waterSupplyElement
  imp_off = 1
  imp_enabled = FALSE
  
  if ("imp_off" %in% cols) {
      imp_off <- as.integer(median(dat$imp_off))
  }
  if (imp_off == 1) { #check if imp_off exists, if not:
    if("impoundment" %in% cols) {
      imp_enabled = TRUE
      paste0('imp_enabled = ', imp_enabled, ' : Impoundment Enabled')
    }
  } else if (imp_off == 0) {
    paste0('imp_off = ', imp_off, ' : Impoundment Enabled')
  }
    
  if (imp_enabled == FALSE & imp_off == 1) {
    paste0('imp_off = ', imp_off, ' and imp_enabled = ', imp_enabled, ' : Impoundment Diabled')
  }
  
  
#### Only do Storage calculation if impoundment is active 
  if (imp_enabled == TRUE | imp_off == 0) {
 
    #Different names for storage and Q values based on object_class:
    if (object_class == "hydroImpoundment") { #from hydroImpoundment.R: colname = "Storage"
      
      #storage col already named "Storage"
      Qcol <- "Qin" #from hydroImpoundment.R: flows <- zoo(dat$Qin, order.by = index(dat));
      
    } else if (object_class == "waterSupplyModelNode") {
      
      dat$Storage <- dat$impoundment_Storage #from waterSupplyModelNode.R: colname = "impoundment_Storage"  
      Qcol <- "Qout" #from waterSupplyModelNode.R: flows <- zoo(as.numeric(as.character( dat$Qout )), order.by = index(dat));
      
    } else if (object_class == "waterSupplyElement") {
      
      # Storage col could be a couple different names 
      if("local_impoundment_Storage" %in% cols) {
        storagecol <- "local_impoundment_Storage"
      }
      if("impoundment_Storage" %in% cols) {
        storagecol <- "impoundment_Storage"
      }
      dat$Storage <- dat[,storagecol]
      if ('Qintake' %in% cols) {
        Qcol <- "Qintake" 
      } else { #from waterSupplyElement.R: flows <- zoo(as.numeric(as.character( dat$Qintake )), order.by = index(dat));
        Qcol <- "Qin" #no Qintake in at least 1 case, use Qin instead
      }
      
    } else { #object_class is something else
      
      dat$Storage <- dat$impoundment_Storage
      Qcol <- "Qout" #Qout is the default
      
    }
     
    #find l30 and l90 years based on Qcol
    flows <- zoo(dat[,Qcol], order.by = index(dat)); 
    loflows <- group2(flows, year = 'calendar') #vahydro Smin metrics used calendar year method 
    
    l90 <- loflows["90 Day Min"];
    ndx = which.min(as.numeric(l90[,"90 Day Min"]));
    l90_Qout = round(loflows[ndx,]$"90 Day Min",6);
    l90_year = loflows[ndx,]$"year";
    l90yr_start = as.Date(paste0(l90_year,"-01-01")) #start of l90 year
    l90yr_end = as.Date(paste0(l90_year,"-12-31")) #end of l90 year
    datpd_90yr <- window( #data for the l90 year
      dat,
      start = l90yr_start,
      end = l90yr_end
    )
    
    l30 <- loflows["30 Day Min"];
    ndx = which.min(as.numeric(l30[,"30 Day Min"]));
    l30_Qout = round(loflows[ndx,]$"30 Day Min",6);
    l30_year = loflows[ndx,]$"year";
    l30yr_start = as.Date(paste0(l30_year,"-01-01"))
    l30yr_end = as.Date(paste0(l30_year,"-12-31"))
    datpd_30yr <- window(
      dat,
      start = l30yr_start,
      end = l30yr_end
    )
  
    ##Near-exact method: Smin within the L30 and L90 periods:
    
    l30yr_df <- as.data.frame(datpd_30yr)
    l90yr_df <- as.data.frame(datpd_90yr)
    
    #zoo of Qcol for each l30 and l90 years
    l30yr_flowz <- window(flows, start = l30yr_start, end = l30yr_end)
    l90yr_flowz <- window(flows, start = l90yr_start, end = l90yr_end)
    
    #zoo to data frame
    l30yr_flows <- data.frame(Q = l30yr_flowz)
    l90yr_flows <- data.frame(Q = l90yr_flowz)
    
    #use rolling mean to identify each low-flow period
    rollmean30 = rollmean(l30yr_flows, k=30, fill=NA, align='left') #results in matrix/array
    rollmean90 = rollmean(l90yr_flows, k=90, fill=NA, align='left')
    
    l30yr_flows$rollmean30 <- rollmean30[,1]
    l90yr_flows$rollmean90 <- rollmean90[,1]
    
    #start row numbers for low flow periods
    rownum_start30 <- which.min(l30yr_flows$rollmean30) #min rolling mean since we used a left alignment 
    rownum_start90 <- which.min(l90yr_flows$rollmean90) 
    
    #end row numbers for low flow periods
    rownum_end30 <- rownum_start30 + 29
    rownum_end90 <- rownum_start90 + 89
    
    #start  and end dates for low flow periods
    l30pd_start <- as.Date(row.names(l30yr_flows[rownum_start30, ]))
    l90pd_start <- as.Date(row.names(l90yr_flows[rownum_start90, ]))
    l30pd_end <- as.Date(row.names(l30yr_df[rownum_end30, ]))
    l90pd_end <- as.Date(row.names(l90yr_df[rownum_end90, ]))
    
    #end rownum cant be greater than length of data 
    # if (rownum_end90 > nrow(l90yr_df)) {
    #   rownum_end90 = nrow(l90yr_df)
    # }
    # if (rownum_end30 > nrow(l30yr_df)) {
    #   rownum_end30 = nrow(l30yr_df)
    # }
    
    #zoos for the drought periods 
    l30pd_flowz <- window(dat, start = l30pd_start, end = l30pd_end)
    l90pd_flowz <- window(dat, start = l90pd_start, end = l90pd_end)
    
    #data for low flow periods
    l30pd_df <- as.data.frame(l30pd_flowz)
    l90pd_df <- as.data.frame(l90pd_flowz)
    
    #Smin within the low flow periods (near-exact method)
      #Storage needs to be converted from acre-feet to million gallons
    storage_data$SminL30mg_nex[i] <- round((min(l30pd_df$Storage) / 3.069), digits = 3)
    storage_data$SminL90mg_nex[i] <- round((min(l90pd_df$Storage) / 3.069), digits = 3)
    
    #get row numbers where near-exact Smin happens within low flow period 
    rownum_nex30 <- which.min(l30pd_df$Storage) 
    rownum_nex90 <- which.min(l90pd_df$Storage)

    #get row numbers where near-exact Smin happens within low flow year 
    rownum_nex30yr <- rownum_start30 + rownum_nex30 - 1
    rownum_nex90yr <- rownum_start90 + rownum_nex90 - 1

    #get row numbers where approx Smin happens within low flow year 
    rownum_apx30 <- which.min(l30yr_df$Storage) 
    rownum_apx90 <- which.min(l90yr_df$Storage)
    
    #test if values occur in the same place
    match30 <- (as.numeric(rownum_nex30yr) == as.numeric(rownum_apx30))
    match90 <- (as.numeric(rownum_nex90yr) == as.numeric(rownum_apx90))
    
    #add TRUE/FALSE to dataframe
    storage_data$min_in_pd30[i] <- paste0(match30)
    storage_data$min_in_pd90[i] <- paste0(match90)
    
    # If approx. and near-exact values are different: 
    # How far outside the low-flow period does the approximate value occur?
      ## Positive: near-exact Smin happens AFTER the approx. Smin 
      ## Negative: near-exact Smin happens BEFORE the approx. Smin 

    if (storage_data$min_in_pd30[i] == FALSE) {
      storage_data$outside_pd30[i] = rownum_nex30yr - rownum_apx30
    }
    if (storage_data$min_in_pd90[i] == FALSE) {
      storage_data$outside_pd90[i] = rownum_nex90yr - rownum_apx90
    }
    
  }
}

#when a min value is repeated, ex. 100s across all storage vals, our method is flawed
  #this causes FALSEs and # of days to show up where we should have TRUE and 0 days 
storage_data[is.na(storage_data)] <- 0 #replace NA values with 0

for (i in 1:nrow(storage_data)) {
  if (storage_data$SminL30mg_apx[i] == storage_data$SminL30mg_nex[i]) {
    storage_data$min_in_pd30[i] <- TRUE
    storage_data$outside_pd30[i] <- 0  
  } 
      
  if (storage_data$SminL90mg_apx[i] == storage_data$SminL90mg_nex[i]) {
    storage_data$min_in_pd90[i] <- TRUE
    storage_data$outside_pd90[i] <- 0
  }
}

```

```{r Smin Method Comparison, echo=FALSE, message=FALSE, warning=FALSE}
#Compare approx and near exact Smin values. Approx should always be <= near exact 
storage_data$apx_lessthan_nex_30 <- NA #empty columns to hold true/false
storage_data$apx_lessthan_nex_90 <- NA 

for (i in 1:nrow(storage_data)) { 
  if (storage_data$SminL30mg_apx[i] <= storage_data$SminL30mg_nex[i]) { #if approx value is <= near exact
    storage_data$apx_lessthan_nex_30[i] = TRUE
  } else {
    storage_data$apx_lessthan_nex_30[i] = FALSE
  }
  
  if (storage_data$SminL90mg_apx[i] <= storage_data$SminL90mg_nex[i]) { #if approx value is <= near exact
    storage_data$apx_lessthan_nex_90[i] = TRUE
  } else {
    storage_data$apx_lessthan_nex_90[i] = FALSE
  }    
  
}

```

```{r Sum Storage by Riverseg, echo=FALSE, message=FALSE, warning=FALSE}
#Approximate Smin Values 

#Sum approx SminL30 by riverseg
storage_byseg_30_apx <- sqldf("SELECT storage_data.riverseg, storage_data.SminL30mg_apx,
                       SUM(SminL30mg_apx) AS SminL30mg_apx_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Sum qpprox SminL90 by riverseg
storage_byseg_90_apx <- sqldf("SELECT storage_data.riverseg, storage_data.SminL90mg_apx,
                       SUM(SminL90mg_apx) AS SminL90mg_apx_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Join approx SminL30 and SminL90 summed storage
storage_byseg_apx <- sqldf("SELECT a.riverseg, a.SminL30mg_apx_sum, b.SminL90mg_apx_sum
                              FROM storage_byseg_30_apx AS a
                              LEFT OUTER JOIN storage_byseg_90_apx AS b
                              WHERE (a. riverseg = b.riverseg) ")


#Near-exact Smin Values 

#Sum near-exact SminL30 by riverseg
storage_byseg_30_nex <- sqldf("SELECT storage_data.riverseg, storage_data.SminL30mg_nex,
                       SUM(SminL30mg_nex) AS SminL30mg_nex_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

# #Sum near-exact SminL90 by riverseg
storage_byseg_90_nex <- sqldf("SELECT storage_data.riverseg, storage_data.SminL90mg_nex,
                       SUM(SminL90mg_nex) AS SminL90mg_nex_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Join near-exact SminL30 and SminL90 summed storage
storage_byseg_nex <- sqldf("SELECT a.riverseg, a.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                              FROM storage_byseg_30_nex AS a
                              LEFT OUTER JOIN storage_byseg_90_nex AS b
                              WHERE (a. riverseg = b.riverseg) ")

#Join Approx and Near-exact Smin values by riverseg
storage_byseg <- sqldf("SELECT a.*,  b.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                              FROM storage_byseg_apx AS a
                              LEFT OUTER JOIN storage_byseg_nex AS b
                              WHERE (a. riverseg = b.riverseg) ")
```

```{r Join Storage + Metric + Baseline Data, echo=FALSE, message=FALSE, warning=FALSE}
#Storage data by riverseg in storage_byseg 
#Metric data by riverseg in metric_data 

#Join storage data onto demand scenario metric data 
metric_data <- sqldf('SELECT a.*, b.SminL30mg_apx_sum, b.SminL90mg_apx_sum, b.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                   FROM metric_data as a
                   LEFT OUTER JOIN storage_byseg as b
                   ON (a.riverseg = b.riverseg)')

#Join baseline scenario data onto demand scenario & storage data 
metric_data <- sqldf('SELECT a.*, b.l30_Qout_base, b.l90_Qout_base
                   FROM metric_data as a
                   LEFT OUTER JOIN baseline_data as b
                   ON (a.riverseg = b.riverseg)')

#Join cumulative demand to storage data for inclusion in tables 
storage_data <- sqldf('SELECT a.*, b.wd_cumulative_mgd
                   FROM storage_data as a
                   LEFT OUTER JOIN metric_data as b
                   ON (a.riverseg = b.riverseg)')

```

```{r Link Upstream Impoundments, echo = FALSE, message=FALSE, warning=FALSE}
#Empty columns that will hold total storage
metric_data$SminL30mg_apx_total <- NA 
metric_data$SminL90mg_apx_total <- NA 
metric_data$SminL30mg_nex_total <- NA 
metric_data$SminL90mg_nex_total <- NA 

for (i in 1:nrow(metric_data)) {
  ups_imp <- fn_extract_basin(storage_byseg, metric_data$riverseg[i]) #find if any upstream segments have an impoundment within
  if (nrow(ups_imp) > 0) {
    ups_impsegs <- data.frame(rivseg = ups_imp$riverseg)
    ups_df <- sqldf("select a.*
                    from storage_byseg as a
                    where riverseg in (select rivseg from ups_impsegs)") #get the upstream impoundments 
    metric_data$SminL30mg_apx_total[i] <- sum(ups_df$SminL30mg_apx_sum) #sum storage available locally and upstream
    metric_data$SminL90mg_apx_total[i] <- sum(ups_df$SminL90mg_apx_sum) 
    metric_data$SminL30mg_nex_total[i] <- sum(ups_df$SminL30mg_nex_sum) 
    metric_data$SminL90mg_nex_total[i] <- sum(ups_df$SminL90mg_nex_sum)
    
  }
}
```

```{r Calculate Water Availability, echo = FALSE, message=FALSE, warning=FALSE}

## Reminder: Perform unit conversions when plugging values into WA equation 
# mgd = cfs / 1.547
metric_data[is.na(metric_data)] <- 0 #replace NA values with 0

#4 total WA values: L30 and L90 for each approx and near exact storage 
metric_data$WA_mgd_30_apx = round((metric_data$l30_Qout_dem / 1.547) - 
  mif_coef*(metric_data$l30_Qout_base / 1.547) + 
  (metric_data$SminL30mg_apx_sum / 30), digits = 3)

metric_data$WA_mgd_90_apx = round((metric_data$l90_Qout_dem / 1.547) - 
  mif_coef*(metric_data$l90_Qout_base / 1.547) + 
  (metric_data$SminL30mg_apx_sum / 90), digits = 3)

metric_data$WA_mgd_30_nex = round((metric_data$l30_Qout_dem / 1.547) - 
  mif_coef*(metric_data$l30_Qout_base / 1.547) + 
  (metric_data$SminL30mg_nex_sum / 30), digits = 3)

metric_data$WA_mgd_90_nex = round((metric_data$l90_Qout_dem / 1.547) - 
  mif_coef*(metric_data$l90_Qout_base / 1.547) + 
  (metric_data$SminL90mg_nex_sum / 90), digits = 3)


```

<!---BLOCK_LANDSCAPE_START--->

# Table 1: Overall Water Availability Across VA
## Every river segment with storage including that from upstream segments. Storage and Water Availability values are given for both approximate and near-exact methods for calculating Smin

```{r Table 1, echo=FALSE, message=FALSE, warning=FALSE, out.width='100%'}
title_table_WA <- paste0('TABLE 1: WATER AVAILABILITY. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario, ', MIF: ', mif_coef)
  
df_WA <- sqldf("SELECT a.* FROM metric_data as a WHERE Sminl30mg_apx_total IS NOT 0")

df_WA$WA_apx_sum <- df_WA$WA_mgd_30_apx + df_WA$WA_mgd_90_apx #sum WA for ordering purposes 

df_WA <- sqldf("SELECT a.* FROM df_WA as a 
                       ORDER BY (a.WA_apx_sum)") #order df with lowest WA at the top 

table_WA <- data.frame(Propname = df_WA$propname,
                     Riverseg = df_WA$riverseg,
                     wd_cumu_mgd = round(df_WA$wd_cumulative_mgd, digits = 3),
                     l30_Qout = round(df_WA$l30_Qout_dem, digits = 3),
                     l30_Qout_base = round(df_WA$l30_Qout_base, digits = 3),
                     l30_Qout_mif = round((df_WA$l30_Qout_base*mif_coef), digits = 3),
                     l90_Qout = round(df_WA$l90_Qout_dem, digits = 3),
                     l90_Qout_base = round(df_WA$l90_Qout_base, digits = 3),
                     l90_Qout_mif = round((df_WA$l90_Qout_base*mif_coef), digits = 3),
                     SminL30mg_apx = df_WA$SminL30mg_apx_total,
                     SminL30mg_nex = df_WA$SminL30mg_nex_total,
                     SminL90mg_apx = df_WA$SminL90mg_apx_total,
                     SminL90mg_nex = df_WA$SminL90mg_nex_total,
                     WA_mgd_30_apx = df_WA$WA_mgd_30_apx,
                     WA_mgd_30_nex = df_WA$WA_mgd_30_nex,
                     WA_mgd_90_apx = df_WA$WA_mgd_90_apx,
                     WA_mgd_90_nex = df_WA$WA_mgd_90_nex)

ftable_WA <- flextable(table_WA) #create flextable
ftable_WA <- add_header_lines(ftable_WA, values= title_table_WA) #add title 

ftable_WA
```


# Table 2: Cases of Differing Minimum Smins by Method 
## The approximate method should always result in the lowest Smin, less than or equal to the near-exact Smin value. Rows highlighted are where this is not the case. Storage has not been summed by river segment or routed downstream with fn_extract_basin for this table.

```{r Table 2, echo=FALSE, message=FALSE, warning=FALSE, out.width='100%'}
title_table_Smin <- paste0('TABLE 2: SMIN DISCREPANCIES. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario, ', MIF: ', mif_coef)

table_Smin <- data.frame(Propname = storage_data$propname,
                     Riverseg = storage_data$riverseg,
                     wd_cumu_mgd = round(storage_data$wd_cumulative_mgd, digits = 3),
                     SminL30mg_apx = storage_data$SminL30mg_apx,
                     SminL30mg_nex = storage_data$SminL30mg_nex,
                     SminL90mg_apx = storage_data$SminL90mg_apx,
                     SminL90mg_nex = storage_data$SminL90mg_nex,
                     apx_lessthan_nex_30 = storage_data$apx_lessthan_nex_30,
                     apx_lessthan_nex_90 = storage_data$apx_lessthan_nex_90)

#order table with rows of interest at the top 
table_Smin <- sqldf("SELECT a.* FROM table_Smin as a 
                       ORDER BY (a.apx_lessthan_nex_30)") 

table_Smin <- sqldf("SELECT a.* FROM table_Smin as a 
                       ORDER BY (a.apx_lessthan_nex_90)") 


ftable_Smin <- flextable(table_Smin) #create flextable

#to highlight when approx is not <= near-exact
rownums30 <- which(table_Smin$apx_lessthan_nex_30 == FALSE, arr.ind = TRUE) #get rows
rownums90 <- which(table_Smin$apx_lessthan_nex_90 == FALSE, arr.ind = TRUE)
rownums <- c(rownums30, rownums90)

ftable_Smin <- flextable::bg(ftable_Smin, i = rownums , bg = "yellow") #add row highlight
ftable_Smin <- add_header_lines(ftable_Smin, values= title_table_Smin) #add title 

ftable_Smin
```


 # Table 3: Smin Method Comparison

```{r Table 3, echo=FALSE, message=FALSE, warning=FALSE, out.width='100%'}
title_table_Storage <- paste0('TABLE 3: SMIN METHOD COMPARISON. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario, ', MIF: ', mif_coef)

#sort table by the sum of 2 values
storage_data[is.na(storage_data)] <- 0 #replace NA values with 0
storage_data$outside_sum <- abs(storage_data$outside_pd30) + abs(storage_data$outside_pd90)
storage_data <- sqldf("SELECT a.* FROM storage_data as a 
                       ORDER BY (a.outside_sum) desc")

table_Storage <- data.frame(Propname = storage_data$propname,
                     Riverseg = storage_data$riverseg,
                     SminL30mg_apx = storage_data$SminL30mg_apx,
                     SminL30mg_nex = storage_data$SminL30mg_nex,
                     SminL90mg_apx = storage_data$SminL90mg_apx,
                     SminL90mg_nex = storage_data$SminL90mg_nex,
                     min_in_pd30 = storage_data$min_in_pd30,
                     min_in_pd90 = storage_data$min_in_pd90,
                     outside_pd30 = storage_data$outside_pd30,
                     outside_pd90 = storage_data$outside_pd90)

ftable_Storage <- flextable(table_Storage) #create flextable
ftable_Storage <- add_header_lines(ftable_Storage, values= title_table_Storage) #add title 

ftable_Storage
```


# Table 4: Impoundments of Interest 

```{r Table 4, echo=FALSE, message=FALSE, warning=FALSE, out.width='100%'}
title_table_imp <- paste0('TABLE 4: IMPOUNDMENTS OF INTEREST. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario, ', MIF: ', mif_coef)

#get impoundments of interest 
imp_df <- data.frame() #empty df to hold impoundment objects 

for (i in 1:length(impoundment_list)) {
  improw <- storage_data[grep(impoundment_list[i], storage_data$propname), ]
  imp_df <- rbind(imp_df, improw)
}

table_imp <- data.frame(Propname = imp_df$propname,
                     Riverseg = imp_df$riverseg,
                     wd_cumu_mgd = round(imp_df$wd_cumulative_mgd, digits = 3), 
                     SminL30mg_apx = imp_df$SminL30mg_apx,
                     SminL30mg_nex = imp_df$SminL30mg_nex,
                     SminL90mg_apx = imp_df$SminL90mg_apx,
                     SminL90mg_nex = imp_df$SminL90mg_nex,
                     outside_pd30 = imp_df$outside_pd30,
                     outside_pd90 = imp_df$outside_pd90)

ftable_imp <- flextable(table_imp) #create flextable
ftable_imp <- add_header_lines(ftable_imp, values= title_table_imp) #add title 

ftable_imp
```

# Table 5: WA Upstream of Impoundments of Interest 

```{r Table 5, echo=FALSE, message=FALSE, warning=FALSE, out.width='100%'}
title_table_ups <- paste0('TABLE 5: WA UPSTREAM OF IMPOUNDMENTS OF INTEREST. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario, ', MIF: ', mif_coef)

#get segs which impoundments of interets are within or downstream of 
ups_df <- data.frame() 

for (i in 1:length(imp_df)) { 
  ups_segs <- fn_extract_basin(metric_data, imp_df$riverseg[i])
  if (nrow(ups_segs) > 0) {
    ups_segs$ds_impoundment <- imp_df[i, 'propname'] # label row with which impoundment is downstream 
  }
  ups_df <- rbind(ups_df, ups_segs)
}

#remove rows matching rows in impoundment df
ups_df <- ups_df[!(ups_df$featureid %in% imp_df$featureid),]

table_ups <- data.frame(Propname = ups_df$propname,
                     Riverseg = ups_df$riverseg,
                     DSimpound = ups_df$ds_impoundment,
                     wd_cumu_mgd = round(ups_df$wd_cumulative_mgd, digits = 3),
                     l30_Qout = round(ups_df$l30_Qout_dem, digits = 3),
                     l30_Qout_base = round(ups_df$l30_Qout_base, digits = 3),
                     l30_Qout_mif = round((ups_df$l30_Qout_base*mif_coef), digits = 3),
                     l90_Qout = round(ups_df$l90_Qout_dem, digits = 3),
                     l90_Qout_base = round(ups_df$l90_Qout_base, digits = 3),
                     l90_Qout_mif = round((ups_df$l90_Qout_base*mif_coef), digits = 3),
                     SminL30mg_apx = ups_df$SminL30mg_apx_total,
                     SminL30mg_nex = ups_df$SminL30mg_nex_total,
                     SminL90mg_apx = ups_df$SminL90mg_apx_total,
                     SminL90mg_nex = ups_df$SminL90mg_nex_total,
                     WA_mgd_30_apx = ups_df$WA_mgd_30_apx,
                     WA_mgd_30_nex = ups_df$WA_mgd_30_nex,
                     WA_mgd_90_apx = ups_df$WA_mgd_90_apx,
                     WA_mgd_90_nex = ups_df$WA_mgd_90_nex)

ftable_ups <- flextable(table_ups) #create flextable
ftable_ups <- add_header_lines(ftable_ups, values= title_table_ups) #add title 

ftable_ups
```


<!---BLOCK_LANDSCAPE_STOP--->

```{r Save Tables as Images, echo=FALSE, message=FALSE, warning=FALSE}
flextable::save_as_image(ftable_WA, path = paste0(export_path, 'WAcaseStudies_WAtable1_', 
                                                  demand_scenario, '_', baseline_scenario, '_', mif_coef, '.png')) #table1

flextable::save_as_image(ftable_Smin, path = paste0(export_path, 'WAcaseStudies_SminTable2_', 
                                                  demand_scenario, '_', baseline_scenario, '_', mif_coef, '.png')) #table2

flextable::save_as_image(ftable_Storage, path = paste0(export_path, 'WAcaseStudies_StorageTable3_', 
                                                  demand_scenario, '_', baseline_scenario, '_', mif_coef, '.png')) #table3

flextable::save_as_image(ftable_imp, path = paste0(export_path, 'WAcaseStudies_impTable4_', 
                                                  demand_scenario, '_', baseline_scenario, '_', mif_coef, '.png')) #table4

flextable::save_as_image(ftable_ups, path = paste0(export_path, 'WAcaseStudies_upsTable5_', 
                                                  demand_scenario, '_', baseline_scenario, '_', mif_coef, '.png')) #table5
```




```{r tab.cap="", tab.id=""}

```

```{r fig.cap="", fig.id = ""}

```


