---
title: "WaterAvailability_CaseStudies"
author: "HARP Analysts"
date: "2024-02-14"
output: word_document

params: 
  impoundment_list: ["Lake Manassas", "Lake Moomaw", "Lake Chesdin", "Lake Anna", "Carvins Cove", "Jennings Randolph Lake"]
  demand_scenario: ["runid_11"] 
  baseline_scenario: ["runid_0"] 
  instream_coeff: [0.9]

---

```{r setup, include=FALSE}
library(data.table)
library(hydrotools)
library(sqldf)
library(flextable)

basepath='/var/www/R'
source('/var/www/R/config.R') 
ds <- RomDataSource$new(site, rest_uname)
ds$get_token(rest_pw)

#source('https://github.com/HARPgroup/om/raw/master/R/summarize/fn_get_pd_min.R') #load Smin_CPL function, approx method

options(scipen = 999) #disable scientific notation

#assign params
for(i in 1:length(params)){
  assign(names(params[i]), params[[i]])
}

#get numeric element of demand scenario runid to use in fn_get_runfile
runid_dem = as.numeric(gsub(".*?([0-9]+).*", "\\1", demand_scenario))             

```

# Water Availability Case Studies 


## Case Study Description 
A case study is a descriptive example of a particular area (ex. a watershed/region) where water availability is calculated. For that example watershed, we can take a detailed look at the individual calculations and resulting values generated.


## Impoundments for case studies:
- Lake Manassas 
- Lake Moomaw
- Lake Chesdin 
- Lake Anna 
- Carvin's Cove 
- Jennings Randolph Lake 


```{r Pull Data, message=FALSE}
#Get storage metrics 
df_storage <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(demand_scenario, demand_scenario),
  'metric' = c('Smin_L30_mg', 'Smin_L90_mg'),
  'runlabel' = c('SminL30mg_apx','SminL90mg_apx')
)
storage_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_storage, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)

#Get demand scenario metrics used in WA eqn
df_metrics <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(demand_scenario, demand_scenario),
  'metric' = c('l30_Qout', 'l90_Qout'),
  'runlabel' = c('l30_Qout_dem', 'l90_Qout_dem')
)
metric_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_metrics, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)

#Get baseline scenario metrics for WA eqn
df_baseline <- data.frame(
  'model_version' = c('vahydro-1.0', 'vahydro-1.0'),
  'runid' = c(baseline_scenario, baseline_scenario),
  'metric' = c('l90_Qout', 'l30_Qout'),
  'runlabel' = c('l90_Qout_base', 'l30_Qout_base')
)
baseline_data <- om_vahydro_metric_grid(
  metric = metric, runids = df_baseline, bundle = 'all', ftype = "all",
  base_url = paste(site,'entity-model-prop-level-export',sep="/"),
  ds = ds
)
```


```{r Smin Calculations, echo = FALSE, message=FALSE, warning=FALSE}

storage_data$SminL30mg_nex <- NA #empty columns to hold near exact storage values
storage_data$SminL90mg_nex <- NA

storage_data$outside_pd30 <- NA #empty columns to hold numeric values
storage_data$outside_pd90 <- NA 

for (i in 1:nrow(storage_data)) {
  #Get runfile with timeseries data from VAhydro
  pid <- storage_data$pid[i]

  token = ds$get_token(rest_pw) #needed for elid function
  elid <- om_get_model_elementid(
    base_url = site,
    mid = storage_data$pid[i]
  )
  rm(token)

  dat <- fn_get_runfile(elid, runid_dem, site= omsite,  cached = FALSE) #get timeseries data (read in as zoo)
  mode(dat) <- 'numeric'
  
  #Get model to get object class
  model <- RomProperty$new(ds,list( 
    featureid = storage_data$featureid[i],
    propcode = 'vahydro-1.0'
  ),TRUE)
  
  #Get object class 
  object_class <- RomProperty$new(ds,list( #get vahydro-1.0 model feature from vahydro
    featureid = model$pid,
    propname = 'object_class'
  ),TRUE)  
  
  object_class <- object_class$propcode
  
  #Trim runfile
  syear = as.integer(min(dat$year))
  eyear = as.integer(max(dat$year))
  if (syear < (eyear - 2)) {
    sdate <- as.Date(paste0(syear,"-10-01"))
    edate <- as.Date(paste0(eyear,"-09-30"))
  } else {
    sdate <- as.Date(paste0(syear,"-02-01"))
    edate <- as.Date(paste0(eyear,"-12-31"))
  }
  dat <- window(dat, start = sdate, end = edate);
  mode(dat) <- 'numeric' 
  cols <- names(dat)
  
  #Different names for storage and Qin values:
  
  if (!('Storage' %in% cols)) { #if a column named Storage does not exist

    if ('impoundment_Storage' %in% cols) {
      names(dat)[names(dat) == 'impoundment_Storage'] <- 'Storage'
    } else if ('local_impoundment_Storage' %in% cols) {
      names(dat)[names(dat) == 'local_impoundment_Storage'] <- 'Storage'
    } else {
      dat$Storage <- 0 #set storage to 0 if not an impoundment feature
    }
  }
  
  #Finding which var/column our group2() should use, based on model object class 
  if (object_class == "hydroImpoundment") {
    Qcol <- "Qin"
  } else if (object_class == "waterSupplyModelNode") {
    Qcol <- "Qout"
  } else if (object_class == "waterSupplyElement") {
      if ('Qintake' %in% cols) { 
        Qcol <- "Qintake" #this column used in waterSupplyElement.R
      } else if ('Qin' %in% cols) {
        Qcol <- "Qin" #no Qintake in at least 1 case, use Qin instead 
      }
  } else { #object_class is something else 
    Qcol <- "Qout" #Qout is the default 
  }
  
  #find l30 and l90 years based on Qcol
  flows <- zoo(dat[,Qcol], order.by = index(dat)); ## Change to var based on object class 
  loflows <- group2(flows, year = 'calendar') #vahydro Smin metrics used calendar year method 
  
  l90 <- loflows["90 Day Min"];
  ndx = which.min(as.numeric(l90[,"90 Day Min"]));
  l90_Qout = round(loflows[ndx,]$"90 Day Min",6);
  l90_year = loflows[ndx,]$"year";
  l90_start = as.Date(paste0(l90_year,"-01-01"))
  l90_end = as.Date(paste0(l90_year,"-12-31"))
  datpd_90 <- window(
    dat,
    start = l90_start,
    end = l90_end
  )
  
  l30 <- loflows["30 Day Min"];
  ndx = which.min(as.numeric(l30[,"30 Day Min"]));
  l30_Qout = round(loflows[ndx,]$"30 Day Min",6);
  l30_year = loflows[ndx,]$"year";
  l30_start = as.Date(paste0(l30_year,"-01-01"))
  l30_end = as.Date(paste0(l30_year,"-12-31"))
  datpd_30 <- window(
    dat,
    start = l30_start,
    end = l30_end
  )

  ##Near-exact method: Smin within the L30 and L90 periods:
  
  #data for each l30 and l90 years
  l30yr_flows <- window(flows, start = l30_start, end = l30_end)
  l90yr_flows <- window(flows, start = l90_start, end = l90_end)
  
  l30yr_data <- window(dat, start = l30_start, end = l30_end)
  l90yr_data <- window(dat, start = l90_start, end = l90_end)
  
  #zoo to data frame
  l30yr_flows <- as.data.frame(l30yr_flows)
  l90yr_flows <- as.data.frame(l90yr_flows)
  
  l30yr_data <- as.data.frame(l30yr_data)
  l90yr_data <- as.data.frame(l90yr_data)
  
  l30yr_df <- l30yr_flows %>% mutate(rollmean_30 = rollmean(l30yr_flows, k=30, fill=NA, align='left' ))
  l90yr_df <- l90yr_flows %>% mutate(rollmean_90 = rollmean(l90yr_flows, k=90, fill=NA, align='left'))
  
  #start dates for low flow periods
  rownum_start90 <- which.min(l90yr_df$rollmean_90) 
  rownum_start30 <- which.min(l30yr_df$rollmean_30)
  
  l30pd_start <- as.Date(row.names(l30yr_df[which.min(l30yr_df$rollmean_30),]))
  l90pd_start <- as.Date(row.names(l90yr_df[which.min(l90yr_df$rollmean_90),]))
  
  #end dates for low flow periods
  rownum_end90 <- which.min(l90yr_df$rollmean_90) + 90
  rownum_end30 <- which.min(l30yr_df$rollmean_30) + 30
  
  #end rownum cant be greater than length of data 
  if (rownum_end90 > nrow(l90yr_df)) {
    rownum_end90 = nrow(l90yr_df)
  }
  if (rownum_end30 > nrow(l30yr_df)) {
    rownum_end30 = nrow(l30yr_df)
  }
  
  l30pd_end <- as.Date(row.names(l30yr_df[rownum_end30, ]))
  l90pd_end <- as.Date(row.names(l90yr_df[rownum_end90, ]))
  
  #flow data for the drought periods 
  l30pd_flows <- window(dat, start = l30pd_start, end = l30pd_end)
  l90pd_flows <- window(dat, start = l90pd_start, end = l90pd_end)
  
  l30pd_df <- as.data.frame(l30pd_flows)
  l90pd_df <- as.data.frame(l90pd_flows)
  
  #Smin within the low flow periods
  #Storage needs to be converted from acre-feet to million gallons
  storage_data$SminL30mg_nex[i] <- round((min(l30pd_df$Storage) / 3.069), digits = 3)
  storage_data$SminL90mg_nex[i] <- round((min(l90pd_df$Storage) / 3.069), digits = 3)
  
  #Does the Smin in the low flow year (approx method) occur within low-flow period? (near-exact)
  minstorage30yr <- min(l30yr_data$Storage)
  minstorage90yr <- min(l90yr_data$Storage)

  n_mins30 <- length(which(l30yr_data$Storage==minstorage30yr))
  n_mins90 <- length(which(l90yr_data$Storage==minstorage90yr))

  yearMinRow30 <- which.min(l30yr_data$Storage)
  yearMinRow90 <- which.min(l90yr_data$Storage)

  if (n_mins30 > 1) {  # workaround for when a min value is repeated, ex. 100s across all storage vals
    storage_data$min_in_pd30[i] <- TRUE
  } else {
    storage_data$min_in_pd30[i] <- between(yearMinRow30, rownum_start30, rownum_end30)
  }
  if (n_mins90 > 1) {
    storage_data$min_in_pd90[i] <- TRUE
  } else {
    storage_data$min_in_pd90[i] <- between(yearMinRow90, rownum_start90, rownum_end90)
  }

  #If not, how far outisde the low flow period?
  if (storage_data$min_in_pd30[i] == FALSE) {
    not_before <- rownum_start30 < yearMinRow30
    not_after <- rownum_end30 > yearMinRow30
    if (not_before == FALSE) {
      storage_data$outside_pd30[i] <- as.numeric(rownum_start30 - yearMinRow30)
    } else if (not_after == FALSE) {
      storage_data$outside_pd30[i] <- as.numeric(yearMinRow30 - rownum_end30)
    }
  }
  if (storage_data$min_in_pd90[i] == FALSE) {
    not_before <- rownum_start90 < yearMinRow90
    not_after <- rownum_end90 > yearMinRow90
    if (not_before == FALSE) {
      storage_data$outside_pd90[i] <- as.numeric(rownum_start90 - yearMinRow90)
    } else if (not_after == FALSE) {
      storage_data$outside_pd90[i] <- as.numeric(yearMinRow90 - rownum_end90)
    }
  }
  
}

```


```{r Smin Method Comparison, echo = FALSE, message=FALSE}

#Compare approx and near exact Smin values. Approx should always be <= near exact 

storage_data$apx_lessthan_nex_30 <- NA #empty columns to hold true/false
storage_data$apx_lessthan_nex_90 <- NA 

for (i in 1:nrow(storage_data)) { 
  if (storage_data$SminL30mg_apx[i] <= storage_data$SminL30mg_nex[i]) { #if approx value is <= near exact
    storage_data$apx_lessthan_nex_30[i] = TRUE
  } else {
    storage_data$apx_lessthan_nex_30[i] = FALSE
  }
  
  if (storage_data$SminL90mg_apx[i] <= storage_data$SminL90mg_nex[i]) { #if approx value is <= near exact
    storage_data$apx_lessthan_nex_90[i] = TRUE
  } else {
    storage_data$apx_lessthan_nex_90[i] = FALSE
  }    
  
}

```



```{r Sum Storage by Riverseg, echo = FALSE, message=FALSE}

#Approximate Smin Values 

#Sum approx SminL30 by riverseg
storage_byseg_30_apx <- sqldf("SELECT storage_data.riverseg, storage_data.SminL30mg_apx,
                       SUM(SminL30mg_apx) AS SminL30mg_apx_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Sum qpprox SminL90 by riverseg
storage_byseg_90_apx <- sqldf("SELECT storage_data.riverseg, storage_data.SminL90mg_apx,
                       SUM(SminL90mg_apx) AS SminL90mg_apx_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Join approx SminL30 and SminL90 summed storage
storage_byseg_apx <- sqldf("SELECT a.riverseg, a.SminL30mg_apx_sum, b.SminL90mg_apx_sum
                              FROM storage_byseg_30_apx AS a
                              LEFT OUTER JOIN storage_byseg_90_apx AS b
                              WHERE (a. riverseg = b.riverseg) ")


#Near-exact Smin Values 

#Sum near-exact SminL30 by riverseg
storage_byseg_30_nex <- sqldf("SELECT storage_data.riverseg, storage_data.SminL30mg_nex,
                       SUM(SminL30mg_nex) AS SminL30mg_nex_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

# #Sum near-exact SminL90 by riverseg
storage_byseg_90_nex <- sqldf("SELECT storage_data.riverseg, storage_data.SminL90mg_nex,
                       SUM(SminL90mg_nex) AS SminL90mg_nex_sum
                       FROM storage_data
                       GROUP BY riverseg
                       ")

#Join near-exact SminL30 and SminL90 summed storage
storage_byseg_nex <- sqldf("SELECT a.riverseg, a.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                              FROM storage_byseg_30_nex AS a
                              LEFT OUTER JOIN storage_byseg_90_nex AS b
                              WHERE (a. riverseg = b.riverseg) ")

#Join Approx and Near-exact Smin values by riverseg
storage_byseg <- sqldf("SELECT a.*,  b.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                              FROM storage_byseg_apx AS a
                              LEFT OUTER JOIN storage_byseg_nex AS b
                              WHERE (a. riverseg = b.riverseg) ")
```


```{r Join Storage + Metric + Baseline Data, echo = FALSE, message=FALSE}
#Storage data by riverseg in storage_byseg 
#Metric data by riverseg in metric_data 

#Join storage data onto demand scenario metric data 
metric_data <- sqldf('SELECT a.*, b.SminL30mg_apx_sum, b.SminL90mg_apx_sum, b.SminL30mg_nex_sum, b.SminL90mg_nex_sum
                   FROM metric_data as a
                   LEFT OUTER JOIN storage_byseg as b
                   ON (a.riverseg = b.riverseg)')

#Join baseline scenario data onto demand scenario & storage data 
metric_data <- sqldf('SELECT a.*, b.l30_Qout_base, b.l90_Qout_base
                   FROM metric_data as a
                   LEFT OUTER JOIN baseline_data as b
                   ON (a.riverseg = b.riverseg)')


```

```{r Link Upstream Impoundments, echo = FALSE, message=FALSE}
#Empty columns that will hold total storage
metric_data$SminL30mg_apx_total <- NA 
metric_data$SminL90mg_apx_total <- NA 
metric_data$SminL30mg_nex_total <- NA 
metric_data$SminL90mg_nex_total <- NA 

for (i in 1:nrow(metric_data)) {
  ups_imp <- fn_extract_basin(storage_byseg, metric_data$riverseg[i]) #find if any upstream segments have an impoundment within
  if (nrow(ups_imp) > 0) {
    ups_impsegs <- data.frame(rivseg = ups_imp$riverseg)
    ups_df <- sqldf("select a.*
                    from storage_byseg as a
                    where riverseg in (select rivseg from ups_impsegs)") #get the upstream impoundments 
    metric_data$SminL30mg_apx_total[i] <- sum(ups_df$SminL30mg_apx_sum) #sum storage available locally and upstream
    metric_data$SminL90mg_apx_total[i] <- sum(ups_df$SminL90mg_apx_sum) 
    metric_data$SminL30mg_nex_total[i] <- sum(ups_df$SminL30mg_nex_sum) 
    metric_data$SminL90mg_nex_total[i] <- sum(ups_df$SminL90mg_nex_sum)
    
  }
}
```


```{r Calculate Water Availability, echo = FALSE, message=FALSE}

## Reminder: Perform unit conversions when plugging values into WA equation 
# mgd = cfs / 1.547
metric_data[is.na(metric_data)] <- 0 #replace NA values with 0

#4 total WA values: L30 and L90 for each approx and near exact storage 
metric_data$WA_mgd_30_apx = round((metric_data$l30_Qout_dem / 1.547) - 
  instream_coeff*(metric_data$l30_Qout_base / 1.547) + 
  (metric_data$SminL30mg_apx_sum / 30), digits = 3)

metric_data$WA_mgd_90_apx = round((metric_data$l90_Qout_dem / 1.547) - 
  instream_coeff*(metric_data$l90_Qout_base / 1.547) + 
  (metric_data$SminL30mg_apx_sum / 90), digits = 3)

metric_data$WA_mgd_30_nex = round((metric_data$l30_Qout_dem / 1.547) - 
  instream_coeff*(metric_data$l30_Qout_base / 1.547) + 
  (metric_data$SminL30mg_nex_sum / 30), digits = 3)

metric_data$WA_mgd_90_nex = round((metric_data$l90_Qout_dem / 1.547) - 
  instream_coeff*(metric_data$l90_Qout_base / 1.547) + 
  (metric_data$SminL90mg_nex_sum / 90), digits = 3)


```

## Table 1: Overall Water Availability Across VA
# Every river segment with storage including that from upstream segments. Storage and Water Availability values are given for both approximate and near-exact methods for calculating Smin

```{r Table 1, echo = FALSE, message=FALSE}
title_table_WA <- paste0('TABLE 1: WATER AVAILABILITY. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario)
  
df_WA <- sqldf("SELECT a.* FROM metric_data as a WHERE Sminl30mg_apx_total IS NOT 0")

table_WA <- data.frame(Propname = df_WA$propname,
                     Riverseg = df_WA$riverseg,
                     l30_Qout = round(df_WA$l30_Qout_dem, digits = 3),
                     l90_Qout = round(df_WA$l90_Qout_dem, digits = 3),
                     l30_Qout_base = round(df_WA$l30_Qout_base, digits = 3),
                     l90_Qout_base = round(df_WA$l90_Qout_base, digits = 3),
                     SminL30mg_apx = df_WA$SminL30mg_apx_total,
                     SminL30mg_nex = df_WA$SminL30mg_nex_total,
                     SminL90mg_apx = df_WA$SminL90mg_apx_total,
                     SminL90mg_nex = df_WA$SminL90mg_nex_total,
                     WA_mgd_30_apx = df_WA$WA_mgd_30_apx,
                     WA_mgd_30_nex = df_WA$WA_mgd_30_nex,
                     WA_mgd_90_apx = df_WA$WA_mgd_90_apx,
                     WA_mgd_90_nex = df_WA$WA_mgd_90_nex)

ftable_WA <- flextable(table_WA) #create flextable
ftable_WA <- add_header_lines(ftable_WA, values= title_table_WA) #add title 

ftable_WA
```




## Table 2: Cases of Differing Minimum Smins by Method 
# The approximate method should always result in the lowest Smin, less than or equal to the near-exact Smin value. Rows highlighted are where this is not the case. Storage has not been summed by river segment or routed downstream with fn_extract_basin for this table.

```{r}
title_table_Smin <- paste0('TABLE 2: SMIN DISCREPANCIES. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario)

table_Smin <- data.frame(Propname = storage_data$propname,
                     Riverseg = storage_data$riverseg,
                     SminL30mg_apx = storage_data$SminL30mg_apx,
                     SminL30mg_nex = storage_data$SminL30mg_nex,
                     SminL90mg_apx = storage_data$SminL90mg_apx,
                     SminL90mg_nex = storage_data$SminL90mg_nex,
                     apx_lessthan_nex_30 = storage_data$apx_lessthan_nex_30,
                     apx_lessthan_nex_90 = storage_data$apx_lessthan_nex_90)


ftable_Smin <- flextable(table_Smin) #create flextable
#highlight when approx is not <= near-exact
rownums30 <- which(table_Smin$apx_lessthan_nex_30 == FALSE, arr.ind = TRUE) #get rows
rownums90 <- which(table_Smin$apx_lessthan_nex_90 == FALSE, arr.ind = TRUE)
rownums <- c(rownums30, rownums90)

ftable_Smin <- flextable::bg(ftable_Smin, i = rownums , bg = "yellow") #add row highlight
ftable_Smin <- add_header_lines(ftable_Smin, values= title_table_Smin) #add title 

ftable_Smin
```


## Table 3: Smin Method Comparison

```{r Table 3, echo = FALSE, message=FALSE}
title_table_Storage <- paste0('TABLE 3: SMIN METHOD COMPARISON. Demand: ', demand_scenario, ', Baseline: ', baseline_scenario)

#sort table by the sum of 2 values
storage_data[is.na(storage_data)] <- 0 #replace NA values with 0
storage_data$outside_sum <- storage_data$outside_pd30 + storage_data$outside_pd90
storage_data <- sqldf("SELECT a.* FROM storage_data as a 
                       ORDER BY (a.outside_sum) desc")

table_Storage <- data.frame(Propname = storage_data$propname,
                     Riverseg = storage_data$riverseg,
                     SminL30mg_apx = storage_data$SminL30mg_apx,
                     SminL30mg_nex = storage_data$SminL30mg_nex,
                     SminL90mg_apx = storage_data$SminL90mg_apx,
                     SminL90mg_nex = storage_data$SminL90mg_nex,
                     outside_pd30 = storage_data$outside_pd30,
                     outside_pd90 = storage_data$outside_pd90)



ftable_Storage <- flextable(table_Storage) #create flextable
ftable_Storage <- add_header_lines(ftable_Storage, values= title_table_Storage) #add title 

ftable_Storage
```


## Map 1: Water Availability by Riverseg
# Map showing available water across VA

```{r}

```


## Graph 1: WA vs. Demand and Flow

```{r}
#demand could be represented by wd_mgd or maybe consumptive_use_frac
#flow will be represented by Qout 
```




## Notes & Discussion 
