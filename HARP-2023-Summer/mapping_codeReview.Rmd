---
title: "Mapping Workflow"
author: "HARP Analysts"
date: "`r Sys.Date()`"
output: html_document
params:
  rivseg: ["JA4_7280_7340"] #["JA4_7280_7340" , "JB3_6820_7053","JL6_7320_7150", "JL7_7070_0001"]  <-last=Richmond
  model_version: ["vahydro-1.0"]
  runid_list: [ "runid_11","runid_13" ]
  metric: ["wd_mgd"]
  map_name: ["James_JL6_7320_7150_cleanup2"]
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(hydrotools)
library(mgsub)
library(sp)
library(rgeos)
library(sf)
library(nhdplusTools)
library(ggmap)
library(raster)
library(ggplot2)
library(ggnewscale)   
library(ggsn)
library(ggspatial)
library(ggrepel)
library(dplyr)
library(flextable)
library(geosphere)

basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new("http://deq1.bse.vt.edu/d.dh", rest_uname)
ds$get_token(rest_pw)
site <- 'http://deq1.bse.vt.edu/d.dh'
```

```{r UserInputs, echo=FALSE}
rivseg <- params$rivseg
model_version <- params$model_version
runid_list <- params$runid_list
metric <- params$metric
map_name <- params$map_name
```

```{r Establish Functions, echo=FALSE}
# Read data that requires file download
download_read <- function(url, filetype, zip) {
  localpath <- tempdir()
  filename <- basename(url)
  filepath <- paste(localpath,"\\", filename, sep="")

  download.file(url, filepath)
  
  if(zip==TRUE){
   folder <- unzip(filepath, exdir=localpath)
   filepath <- grep(".*.csv.*", folder, value=TRUE)
  }
  if(filetype=="csv"){
    df <- read.csv(file=filepath, header=TRUE, sep=",")
  }
  if(filetype=="shp"){
    layer <- gsub("\\.zip", "", filename)
    df <- read_sf(dsn=localpath, layer=layer)
  } 
  if(filetype!="csv" & filetype!="shp"){
    message(paste("Error in download_read(): filetype must be 'csv' or 'shp'"))
  }
  return(df)
}
#- - - - - - - - - - -

# Convert any data frame w/ geometry stored as Well Known Text to "SpatialXxxDataFrame" (Xx_sp)
## Specify the data frame and the character name of the geometry column
process_geom <- function(data, geom_col) {
  for (i in 1:nrow(data)) {
    sp.i <- sp::addAttrToGeom(
      x=readWKT(data[i,geom_col]), 
      y=as.data.frame(as.list(subset(data[i,],select=-c(names(data)==geom_col)))),      
      match.ID=TRUE
    )
    if (i == 1) {
      # start with one 
      data_sp <- sp.i
    } else {
      # append
      data_sp <- rbind(data_sp, sp.i)
    }
  }
  return(data_sp)
}
#- - - - - - - - - - -

# Add centroid coords to a data frame
centroid_coords <- function(data, geom_col) {
  for (r in 1:nrow(data)) { #get centroid coord. for labeling
    centroid <- st_centroid(data[r, geom_col])
    centroid <- as.data.frame(st_coordinates(centroid))
    data$lng[r] <- centroid$X
    data$lat[r] <- centroid$Y
  }
  return(data)
}
#- - - - - - - - - - -

# Generate user-understandable legend titles
## Kept up here as a function so that it's easy to add if-statements when user-input options expand
legend_titling <- function(metric, runid_list){
  if(metric=="wd_mgd"){
    name <- "Withdrawal"
    unit <- "(MGD)"
  }
  year <- mgsub(runid_list, c("runid_11","runid_13"), c("2020","2040"))
  legend_title <- runid_list               
  for(i in 1:length(runid_list)){
    legend_title[i] <- paste(year[i],name,unit,sep="\n")
  }
  return(legend_title)
}

```

# PULL Data 
```{r PULL Data, echo=FALSE, message=FALSE, warning=FALSE}
#----From Local Machine----
facils <- list()
# Foundational Facilities data
## config.local.private determines wd variable
## wd includes path from main drive up to where individual stores GitHub Repo's
facils$foundatn <- fread(paste0(wd, 'Foundational_Data/2023/foundation_dataset_mgy_1982-2022.csv'))

#----From VAhydro----
# All vahydro watershed features
#segs$all <- ds$get('dh_feature', config=list(ftype='vahydro',bundle='watershed')) ##gives errors
segs <- list()
segs$all <- download_read(url=paste(site,"/vahydro_riversegs_export",sep=""), filetype="csv", zip=FALSE) ##TEMPORARY work-around

# All facility model data
df <- data.frame(runid=runid_list, model_version, metric=metric)
for(i in 1:length(runid_list)){
  df$runlabel[i] <- paste("metric_","runid", i, sep="")
}
facils$mdat <- om_vahydro_metric_grid( 
  metric=FALSE, runids=df, featureid='all', 
  entity_type='dh_feature', bundle='facility',
  ftype='all', model_version = model_version,
  base_url = "http://deq1.bse.vt.edu/d.dh/entity-model-prop-level-export",
  ds = ds
)
remove(df) #job finished?

# County Features data
counties <- list()
counties$df <- ds$get('dh_feature', config=list(bundle='usafips'))

#----From Public Webpages----
# (shp) for US states & primary roads
## VA state is used to filter road data & determine extent levels
roads <- list()
roads$state <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/STATE/tl_2022_us_state.zip",
                             filetype="shp", zip=TRUE)
roads$sf <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/PRIMARYROADS/tl_2022_us_primaryroads.zip",
                          filetype="shp", zip=TRUE)
# (csv) for US cities
cities <- download_read("https://simplemaps.com/static/data/us-cities/1.76/basic/simplemaps_uscities_basicv1.76.zip",
                        filetype="csv", zip=TRUE)

#rivr_maj <- read.csv("https://github.com/HARPgroup/HARParchive/raw/master/GIS_layers/MajorRivers.csv")
## note for rivr_maj: must use read.csv() so that we can apply process_geom() later
## fread() returned class ["data.table" "data.frame"] whereas read.csv() returns class ["data.frame"]

```
# PROCESS Data
```{r PROCESS Data, echo=FALSE, warning=FALSE}
#----General data organization----

# Full join facility model data & facility foundation data
## merge() documentation says "all=TRUE" gives a full outer join by SQL terms
facils$all <- merge(x=facils$mdat, y=facils$foundatn, by.x="featureid", by.y="Facility_hydroid", all=TRUE)
## To place rows with matches at the top:
#facils$all <- facils$all[order(facils$all$riverseg, na.last=TRUE),]

# Extract basin of user-input rivseg, from segs$all
segs$all$riverseg <- str_replace(segs$all$hydrocode, 'vahydrosw_wshed_', '') #prerequisite for fn_extract_basin()
segs$basin <- fn_extract_basin(segs$all, rivseg)

# Filter down to facilities within the basin
## first rename column so it doesn't have the same name as basin's hydrocode column
colnames(facils$all) <- gsub("hydrocode", "facil_hydrocode", colnames(facils$all))
facils$basin <- subset(facils$all, riverseg %in% segs$basin$riverseg & riverseg!="NULL")

# Filter out WSP entries (optional)
##facils$basin <- sqldf("select * from facils$basin where facil_hydrocode not like 'wsp_%'")
facils$basin <- subset(facils$basin, 
                       facil_hydrocode %in% grep("^wsp_", facils$basin$facil_hydrocode, value=TRUE, invert=TRUE) )

# Order by largest metrics; then number them
facils$basin <- facils$basin[order(-facils$basin$metric_runid1, -facils$basin$metric_runid2),]
facils$basin$NUM <- seq(1, nrow(facils$basin))
# Legend title
legend_title <- legend_titling(metric, runid_list)

#- - - - - - - - - - -

# Filter roads to only Interstate, US Hwy, State Rte
roads$state <- roads$state[roads$state$NAME=="Virginia", ] 
roads$sf <- st_intersection(roads$sf, roads$state) #only VA primary roads
## keep only interstate, US hwy, or state Rte.
roads$sf <- subset(roads$sf, RTTYP=="I" | FULLNAME %in% grep("US Hwy.*", roads$sf$FULLNAME, value=TRUE) | RTTYP=="S")
## shorten names to number only; column RTTYP gives classification I, U, or S
roads$sf$FULLNAME <- mgsub(roads$sf$FULLNAME, pattern=c("\\I- ", "US Hwy ", "State Rte "), replacement=c("","",""))
## remove any road followed by Bus, Byp, Alt, etc. by removing any row whose name still has a space
roads$sf <- subset(roads$sf, !(FULLNAME %in% grep(".* .*", roads$sf$FULLNAME, value=TRUE)))
roads$sf <- centroid_coords(roads$sf, "geometry") #add centroid coords

# Filter/classify major cities & small towns
cities <- cities[cities$state_id == 'VA',] #VA cities
popul <- quantile(cities$population, probs = c(0.25, 0.5, 0.75)) 
cities <- cities %>%
  mutate(class = case_when(
    population < popul["75%"] & population > popul["50%"] | population < popul["25%"] ~ "NULL",
    population >= popul["75%"] ~ "majC",
    population <= popul["50%"] & population >= popul["25%"] ~ "town" #exclude smallest populations of 0-400
    ))
cities <- cities[cities$class!="NULL",]

#- - - - - - - - - - -

# Process Polygons; text-> spatial -> simple features
## basin watersheds
segs$basin_sp <- process_geom(segs$basin, "geom")
segs$basin_sf <- st_as_sf(segs$basin_sp)
st_crs(segs$basin_sf) <- 4326 #Set coord. reference syst.
## counties
counties$sp <- process_geom(counties$df, "dh_geofield")
counties$sf <- st_as_sf(counties$sp)
counties$sf <- centroid_coords(counties$sf, "geometry")
st_crs(counties$sf) <- 4326

#- - - - - - - - - - -

# NHD data within the basin area
sf_use_s2(FALSE) # switch off Spherical geometry
bbox <- st_buffer(st_as_sfc(st_bbox(segs$basin_sf)), .2) #slightly past basin
nhd  <- plot_nhdplus(bbox = st_bbox(bbox), actually_plot = FALSE)

```


```{r}
## Calculating 5-year average use by source from the foundational data frame 
facils$found_num <- facils$basin[, (ncol(facils$basin)-5):(ncol(facils$basin)-1)]  #create new df with only the numeric use/withdrawal data
fiveyr_avg_mgy <- round(rowMeans(facils$found_num, na.rm = TRUE), 2)
facils$basin$fiveyr_avg_mgy_2 <- fiveyr_avg_mgy
```


```{r Labels df & Extent Filters}
# River & stream labels
## major rivs = orders 5 & 6; streams = order 4
lb_rivr <- nhd$flowline[nhd$flowline$gnis_name!=' ' & #name!=blank & order 4, 5, or 6
                         (nhd$flowline$StreamOrde==6 | nhd$flowline$StreamOrde==5 | nhd$flowline$StreamOrde==4),] 
## no duplicate names; prioritize higher order names and then the longest segment of each duplicate
lb_rivr <- lb_rivr[order(-lb_rivr$StreamOrde, lb_rivr$gnis_name, -lb_rivr$LENGTHKM) & !duplicated(lb_rivr$gnis_name),]
## shorten long names
lb_rivr$gnis_name <- mgsub(lb_rivr$gnis_name, 
                             c('North Fork','South Fork','East Fork','West Fork','Middle Fork'), #pattern
                             c('NF','SF','EF','WF','MF')) #replacement
lb_rivr$StreamOrde <- mgsub(lb_rivr$StreamOrde, c(4,5,6), c("str","majR","majR"))
## calculate label coordinates
lb_rivr <- centroid_coords(lb_rivr, "geometry")

# Waterbody labels
lb_wtbd <- rbind(nhd$network_wtbd, nhd$off_network_wtbd)
## remove ones without names & filter to largest 50%
lb_wtbd <- lb_wtbd[!(lb_wtbd$gnis_name==' ' | lb_wtbd$gnis_name=='Noname') & lb_wtbd$AreaSqKM > quantile(lb_wtbd$AreaSqKM, 0.5),]
lb_wtbd <- centroid_coords(lb_wtbd, "geometry")

#- - - - - - - - - - -

# Combine all labels into one df
labels <- data.frame(
  name= c(counties$sf$name, cities$city, lb_rivr$gnis_name, lb_wtbd$gnis_name, roads$sf$FULLNAME[!duplicated(roads$sf$FULLNAME)]),
  class= c(counties$sf$ftype, cities$class, lb_rivr$StreamOrde, lb_wtbd$FTYPE, roads$sf$RTTYP[!duplicated(roads$sf$FULLNAME)]),
  lng= as.numeric( c(counties$sf$lng, cities$lng, lb_rivr$lng, lb_wtbd$lng, roads$sf$lng[!duplicated(roads$sf$FULLNAME)]) ),
  lat= as.numeric( c(counties$sf$lat,cities$lat, lb_rivr$lat, lb_wtbd$lat, roads$sf$lat[!duplicated(roads$sf$FULLNAME)]) )
)
remove(lb_rivr)
remove(lb_wtbd)

# Columns for the aesthetics
## very specific function; just minimizing code lines:
class_aes <- function(aesthetic){ #input values of an aesthetic to correspond with each label class
  mgsub(labels$class, c("I","S","U","town","majC","LakePond","str","majR","county"), aesthetic)
}
labels$road <- class_aes( c(rep("yes",3), rep("no",6)) )

labels$fontface <- class_aes( c(rep("plain",5),"bold","bold","bold","bold.italic") )
labels$fontfam <- class_aes( c(rep("Comic Sans MS",3),"sans","sans",rep("serif",4) ) )
labels$angle <- as.numeric( class_aes( c(0,0,0,0,0,15,15,15,0) ) ) #as.numeric() b/c mgsub() returns character strings
labels$bg.r <- as.numeric( class_aes( c("NA","NA","NA",.05,.05,.1,.1,.05,.03) ) )
labels$segsize <- as.numeric( class_aes( c("NA","NA","NA",.5,.5,.5,.5,.75,1) ) )

textcol <- c("red","white","black","deepskyblue4","#003333") #c(I, S, U/town/majC, LakePond/str/majR, county)
labels$segcol <- class_aes( c("NA","NA","NA", textcol[c(3,3,4,4,4,5)] ) )
labels$colcode <- class_aes( c(1,2,3,3,3,4,4,4,5) ) #corresponds to textcol for the color scale

labels$sizecode <- as.numeric ( class_aes( c(1,1,1,2,2,2,2,3,4) ) ) #corresponds to textsize for the size scale

label_fill <- c("blue","#0B5F14","white") #for road bubbles c(I,S,U)
labels$fill <- class_aes( c(1,2,3, rep("NA",6) ) )

#- - - - - - - - - - -

# Basemap boundary box
bbox <- st_buffer(st_as_sfc(st_bbox(segs$basin_sf)), .05) #slightly larger than basin
bbox <- st_bbox(bbox)

#- - - - - - - - - - -

# Calculation of extent = get diagonal of bbox in miles
extent <- tibble(lng = bbox[c("xmin", "xmax")], lat = bbox[c("ymin", "ymax")] )
## distHaversine() defaults to meters, so convert to miles
extent <-  distHaversine(extent) / 1609.34

# Via same calculation, extent of all of VA state's bbox (aka absolute max extent): ~506 mi
## James JL6_7320_7150 basin's extent is ~140 mi ; considering this a large basin relative to most maps
## Roanoke city's extent < 13 mi ; basing absolute minimum extents off of this
if(extent > 300) {
  zoom = 8 #basemap resolution
  nhd$plot <- nhd$flowline[nhd$flowline$StreamOrde!=1 & nhd$flowline$StreamOrde!=2 & nhd$flowline$StreamOrde!=3,]
  roads$plot <- roads$sf[roads$sf$RTTYP=="I",]
  labelsP <- labels[labels$class=="county" | labels$class=="majR" | labels$class=="majC" | labels$class=="I",]
  textsize <- c(4,4,5,6,  5,0) #c(I/S/U , town/majC/LakePond/str , majR , county ,   facility num , segs$basin_sf lwd)
} else if(extent > 130){
  zoom = 9
  nhd$plot <- nhd$flowline[nhd$flowline$StreamOrde!=1 & nhd$flowline$StreamOrde!=2,]
  roads$plot <- roads$sf
  labelsP <- labels[labels$class!="town" & labels$class!="LakePond",]
  textsize <- c(5,5,6,11,  5,1)
} else if(extent > 70){
  zoom = 10
  nhd$plot <- nhd$flowline[nhd$flowline$StreamOrde!=1,]
  roads$plot <- roads$sf
  labelsP <- labels[labels$class!="town"& labels$class!="LakePond",]
  textsize <- c(6,7,9,12,  5,1.2)
  labels$segsize <- as.numeric( gsub(1, 0, labels$segsize) ) #no label "lollipop" for counties @ small extents
} else {
  zoom = 10
  nhd$plot <- nhd$flowline
  roads$plot <- roads$sf
  labelsP <- labels
  textsize <- c(7,8,10,13,  5,1.5)
  labels$segsize <- as.numeric( gsub(1, 0, labels$segsize) ) 
}

# Create map base
bbox <- setNames(st_bbox(bbox), c("left", "bottom", "right", "top")) #otherwise get_stamenmap() won't run
basemap_0 <- ggmap::get_stamenmap(maptype="terrain-background", color="color", bbox=bbox, zoom=zoom)
basemap <- ggmap(basemap_0)

#- - - - - - - - - - -

# Reverse polygon fill (highlight basin)
bb <- unlist(attr(basemap_0, "bb"))
coords <- cbind( bb[c(2,2,4,4)], bb[c(1,3,3,1)] )
basemap_0 <- sp::SpatialPolygons(
  list(sp::Polygons(list(Polygon(coords)), "id")), 
  proj4string = CRS(proj4string(segs$basin_sp)))
remove(coords) #job done

nonbasin <- raster::erase(basemap_0, segs$basin_sp)
nonbasin <- st_as_sf(nonbasin)
st_crs(nonbasin) <- 4326

# Lighten terrain basemap
basemap_0 <- st_as_sf(basemap_0)
st_crs(basemap_0) <- 4326

```

# PLOT Map
```{r PLOT Data, echo=FALSE}
map <- basemap + #ggplot2::
    # Titles
    theme(text=element_text(size=30), title=element_text(size=40),
          axis.title.x=element_blank(), axis.title.y=element_blank()  ) +
    ggtitle( paste("Basin Upstream of", segs$basin$name[segs$basin$riverseg==rivseg] , rivseg, sep=" ") ) +
  
    # Lighten base-map to help readability
    geom_sf(data = basemap_0, inherit.aes=FALSE, color=NA, fill="honeydew", alpha=0.3) +
    # County Borders
    geom_sf(data = counties$sf, inherit.aes=FALSE, color="#0033337F", fill=NA, lwd=2.5) +
    # Flowlines & Waterbodies
    geom_sf(data = nhd$plot, 
            inherit.aes=FALSE, color="deepskyblue3", 
            mapping=aes(lwd=nhd$plot$StreamOrde), #line thickness based on stream order
            show.legend=FALSE) + 
        scale_linewidth(range= c(0.4,2)) + 
    geom_sf(data = rbind(nhd$off_network_wtbd, nhd$network_wtbd),
            inherit.aes=FALSE, color="deepskyblue3", size=1) +
    # Road Lines
    geom_sf(data = roads$plot, inherit.aes=FALSE, color="black", fill=NA, lwd=1, linetype="twodash") +
    # City Points
    geom_point(data = labelsP[labelsP$class=="majC"|labelsP$class=="town",], 
               aes(x=lng, y=lat), color ="black", size=2) +
    # Basin Outlines
    geom_sf(data = segs$basin_sf, inherit.aes=FALSE, color="sienna1", fill=NA, lwd=textsize[6], linetype="dashed") +
    
    # Facility Labels Placeholder (to have other labels repel)
    geom_text(data = facils$basin, aes(Longitude, Latitude, label=NUM),colour=NA,size=textsize[4],check_overlap=TRUE) +
    # Road Labels
    geom_label_repel(data = labelsP[labelsP$road=="yes",],
                aes(x=lng, y=lat, label=name, 
                    fontface=fontface, family=fontfam,
                    color=colcode, 
                    fill=fill
                    ), 
                show.legend=NA,
                size=textsize[1],
                label.r=0.6, label.size=0.12, 
                #force=0, max.overlaps=1
                ) +
        scale_colour_manual(values=textcol, breaks=c(1,2,3),
                            labels=c("Interstate","State Route", "US Hwy"), name="") + 
        scale_fill_manual(values=label_fill, breaks=c(1,2,3),
                          labels=c("Interstate","State Route", "US Hwy"), name="" ) +
     # Text Labels
        new_scale("size") + new_scale("color") +
    geom_text_repel(data = labelsP[labelsP$road=="no",], 
                    aes(x=lng, y=lat, label=name,
                        fontface=fontface, family=fontfam, angle=angle,
                        segment.color=segcol, segment.size=segsize,
                        bg.color="white", bg.r=bg.r,
                        size=sizecode, 
                        color=colcode,
                        ), 
                    show.legend=FALSE,
                    force= 40, direction="both",
                    min.segment.length=0.5
                    ) + 
          scale_size(range= range(textsize[2:4]), breaks=textsize[2:4] ) + 
          scale_colour_manual(values=textcol, breaks=seq(1,length(textcol)) ) +

    # Facility Points; Metric 1
        new_scale("size") + new_scale("color") +
      geom_point(data = facils$basin, 
                 aes(x=Longitude, y=Latitude, size=metric_runid1, color=facils$basin[,"Source Type"]), 
                 alpha=0.75, shape = 19, stroke = 0.75 ) +
      scale_size(range= c(10,28), 
                 breaks= seq(max(facils$basin$metric_runid1), 0, length.out=5), 
                 labels= round(seq(max(facils$basin$metric_runid1), 0, length.out=5), digits=3),
                 name= legend_title[1],
                 guide= guide_legend(override.aes=list(label=""))
                 ) + #NOTE: two scales would need identical "name" and "labels" to become one simultaneous legend
      scale_colour_manual(values=c("#F7FF00","#FF00FF"),
                 breaks= c("Surface Water", "Groundwater"),
                 labels= c("Surface Water", "Groundwater"),
                 name= "Source Type",
                 guide= guide_legend(override.aes=list(label=""))
                 ) +
    # Facility Labels
    geom_text(data = facils$basin, 
                    aes(Longitude, Latitude, label=NUM, fontface="bold"), 
                    colour="black", size=textsize[5], check_overlap=TRUE ) +
    # Reverse Fill
    geom_sf(data = nonbasin, inherit.aes=FALSE, color=NA, fill="#4040408F", lwd=1 ) +
    # Scalebar & North Arrow
    ggsn::scalebar(data = segs$basin_sf, dist= round((extent/20),digits=0), 
                   dist_unit='mi', location='bottomleft', transform=TRUE, model='WGS84', 
                   st.bottom=FALSE, st.size=textsize[4], st.dist=0.03, box.color= "#FF00FF", boarder.size= 12 
                   ) +
    ggspatial::annotation_north_arrow(which_north="true", location="tr",
                                      height= unit(4,"cm"), width= unit(3, "cm"), 
                                      style= north_arrow_orienteering(text_size=35)
                                      )
```

```{r Save PNG, echo=FALSE }
ggsave(
  filename = paste(export_path, map_name, ".png", sep=""),
  plot = map,
  width = 25,
  height = 20
  )
```

#Create Table Data
``` {r Create Table Data, warning=FALSE, message=FALSE }

# - - - - creating initial data frame  - - - -
table <- data.frame(Number= facils$basin$NUM, 
                        Facility=facils$basin$Facility, 
                        Source_Type = facils$basin$`Source Type`,
                        Source = facils$basin$`MP Name`,
                        Rivseg= facils$basin$riverseg,
                        Locality = facils$basin$Locality
                        ) 

#- - - -add upstream or downstream - - -

#needs to be adjusted 
for(i in 1:nrow(facils$basin)){ 
  if(facils$basin$riverseg[i] == rivseg)
  {
    up_down<- "Upstream"
    table$Upstream_Downstream[i] <- up_down
  }
  else if (facils$basin$riverseg[i] != rivseg)
  {
    up_down <- "Downstream"
    table$Upstream_Downstream[i] <- up_down
  }
}

#- - - - add permitted capacity - - -

for (i in 1:nrow(facils$basin)){
  systemObj <- RomProperty$new(ds,list(
    featureid = facils$basin$featureid[i],
    propcode= "vahydro-1.0"), 
  TRUE)
  permCapac <- RomProperty$new(ds,list(
  featureid = systemObj$pid,
  propname = 'vwp_max_mgy'),
  TRUE)
  table$vwp_max_mgy[i] <- permCapac$propcode  
}

#Replace zeros with "no permit"
table$vwp_max_mgy <-  replace(table$vwp_max_mgy, table$vwp_max_mgy==0, "No Permit")

#- - - - add 5 yr avg use (MGY) with wd current- PER FACILITY - - -

for (i in 1:nrow(facils$basin)){
val <- RomProperty$new(ds,list(
    featureid= facils$basin$featureid[i],
    propname= "wd_current_mgy"), 
  TRUE)
five_mgy <- val$propvalue
table$five_mgy[i] <- round(five_mgy,2)
}

#- - -  5 year avg PER SOURCE - - - 

#what 5 years should we be using 
#why are the numbers sometimes very different

#for (i in 1:nrow(facils$basin)){
#  fiveavg <- mean(na.omit(facils$basin$'2022'[i],facils$basin$'2021'[i],facils$basin$'2020'[i],facils$basin$'2019'[i],facils$basin$'2018'[i], na.rm= TRUE))
#  table$five_mgy_new[i] <- round(fiveavg, 2)
#}

table$five_mgy_new <- facils$basin$fiveyr_avg_mgy_2
```
# Call Table 
``` {r Call Table, echo= False, warning= False}
#set table defaults of theme and font and make sure theres no blanks from nas 
set_flextable_defaults(
  font.size = 10, theme_fun = theme_zebra, 
  padding = 6, 
  na_str = "NA", nan_str = "NA")

table <- flextable(table)

#change titles of columns in table
table <- set_header_labels(table,
  Facility = "Facility Name", 
  NUM = "Facility Number", 
  Source_Type = "Source Type",
  Rivseg= "River Segment", 
  Locality = "Location(County)",
  Upstream_Downstream = "Upstream Vs. Downstream", 
  five_mgy = "5 Year Average Use - Facility(mgy)",
  vwp_max_mgy = "Permitted Capacity(mgy)",
  five_mgy_new = "5 Year Average Use - Source(mgy)"
  
)
#alignment of table
table %>% 
  autofit() %>%
  flextable::align(align = "center", j = c(1:9), part = "all") 
```