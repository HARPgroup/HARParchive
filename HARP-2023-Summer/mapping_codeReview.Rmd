---
title: "Mapping Workflow"
author: "HARP Analysts"
date: "`r Sys.Date()`"
output: html_document
params:
         #["JL6_7430_7320"]
        #["JA4_7280_7340" , "JB3_6820_7053","JL6_7320_7150", "JL7_7070_0001"]  <-last=Richmond
        #["JL6_7320_7150","JL6_6890_6990","JL6_7430_7320","JA2_7410_7470", "JA4_7280_7340","JB3_6820_7053"] 
  rivseg: ["JL6_7320_7150"] 
  locality: ["Culpeper"]
  region: ["NewRiver_2"]    
  type: ["basin"] #should be one of: basin, locality, or region ; depending on what map type is desired 
  model_version: ["vahydro-1.0"]
  runid_list: [ "runid_11", "runid_13" ] # should be 'NULL' if a non-runid metric used (fiveyr_avg_mgy)
  metric: ["wd_mgd"] # 5-year avg metric called 'fiveyr_avg_mgy' , which is part of foundational data frame, and not tied to a runid 
  map_name: ["Culpeper"]
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(hydrotools)
library(mgsub)
library(sp)
library(rgeos)
library(sf)
library(nhdplusTools)
library(ggmap)
library(raster)
library(ggplot2)
library(ggnewscale)   
library(ggsn)
library(ggspatial)
library(ggrepel)
library(flextable)
library(geosphere)

basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new(site, rest_uname)
ds$get_token(rest_pw)
```

```{r Load External Functions, echo=FALSE}
source(paste0(getwd(), '/', 'fn_mapgen_est.R' )) #load mapping function
source(paste0(getwd(), '/', 'mapstyle_config.R' )) #load mapping aesthetics
source(paste0(getwd(), '/', 'fn_tablegen.R' )) #load table function
```

```{r UserInputs, echo=FALSE}
rivseg <- params$rivseg #for mapping extent of basin(s)
locality <- params$locality #for mapping extent of a locality
region <- params$region #for mapping extent of a region 
type <- params$type #to tell script what type/extent of map to create
model_version <- params$model_version
runid_list <- params$runid_list
metric <- params$metric
map_name <- params$map_name
```

```{r Establish Functions, echo=FALSE}
# Read data that requires file download
download_read <- function(url, filetype, zip) {
  localpath <- tempdir()
  filename <- basename(url)
  filepath <- paste(localpath,"\\", filename, sep="")

  download.file(url, filepath)
  
  if(zip==TRUE){
   folder <- unzip(filepath, exdir=localpath)
   filepath <- grep(".*.csv.*", folder, value=TRUE)
  }
  if(filetype=="csv"){
    df <- read.csv(file=filepath, header=TRUE, sep=",")
  }
  if(filetype=="shp"){
    layer <- gsub("\\.zip", "", filename)
    df <- read_sf(dsn=localpath, layer=layer)
  } 
  if(filetype!="csv" & filetype!="shp"){
    message(paste("Error in download_read(): filetype must be 'csv' or 'shp'"))
  }
  return(df)
}
#- - - - - - - - - - -

# Convert any data frame w/ geometry stored as Well Known Text to "SpatialXxxDataFrame" (Xx_sp)
## Specify the data frame and the character name of the geometry column
process_geom <- function(data, geom_col) {
  for (i in 1:nrow(data)) {
    sp.i <- sp::addAttrToGeom(
      x=readWKT(data[i,geom_col]), 
      y=as.data.frame(as.list(subset(data[i,],select=-c(names(data)==geom_col)))),      
      match.ID=TRUE
    )
    if (i == 1) {
      # start with one 
      data_sp <- sp.i
    } else {
      # append
      data_sp <- rbind(data_sp, sp.i)
    }
  }
  return(data_sp)
}
#- - - - - - - - - - -

# Add centroid coords to a data frame
centroid_coords <- function(data, geom_col) {
  
  #NEW:
#  if(class(data[[geom_col]])=="character"){
#    data <- process_geom(data, geom_col)
#    data <- st_as_sf(data)
#  } #.
  
  for (r in 1:nrow(data)) { #get centroid coord. for labeling
    centroid <- st_centroid(data[r, geom_col])
    centroid <- as.data.frame(st_coordinates(centroid))
    data$lng[r] <- centroid$X
    data$lat[r] <- centroid$Y
  }
  
  #NEW:
  st_crs(data) <- 4326
  #.
  return(data)
}
#- - - - - - - - - - -

# Generate user-understandable legend titles
## Kept up here as a function so that it's easy to add if-statements when user-input options expand
legend_titling <- function(metric, runid_list){
  if(metric=="wd_mgd"){
    name <- "Withdrawal"
    unit <- "(MGD)"
    legend_title <- runid_list
    year <- mgsub(runid_list, c("runid_11","runid_13"), c("2020","2040"))
  for(i in 1:length(runid_list)){
    legend_title[i] <- paste(year[i],name,unit,sep="\n")
  }
  }
  if(metric=="fiveyr_avg_mgy"){ #this metric isn't associated w a runid
    name <- "5-yr Avg Use"
    unit <- "(MGY)"
    legend_title<- paste(name,unit,sep="\n")
  }
  return(legend_title)
}
```

# PULL Data 
```{r PULL Data, echo=FALSE, message=FALSE, warning=FALSE}
#----From Local Machine----
facils <- list()
# Foundational Facilities data
## config.local.private determines wd variable
## wd includes path from main drive up to where individual stores GitHub Repo's
facils$foundatn <- fread(paste0(wd, 'Foundational_Data/2023/foundation_dataset_mgy_2018-2022_5ya.csv'))

#----From VAhydro----
# All vahydro watershed features
#segs$all <- ds$get('dh_feature', config=list(ftype='vahydro',bundle='watershed')) ##gives errors
segs <- list()
segs$all <- download_read(url=paste(site,"/vahydro_riversegs_export",sep=""), filetype="csv", zip=FALSE)
# note: potential NULLs for newly carved data

# All facility model data
  df <- data.frame(runid=runid_list, model_version, metric=metric)
  for(i in 1:length(runid_list)){
  df$runlabel[i] <- paste0(runid_list[i], '_', metric)
}

facils$mdat <- om_vahydro_metric_grid( 
  metric=FALSE, runids=df, featureid='all', 
  entity_type='dh_feature', bundle='facility',
  ftype='all', model_version = model_version,
  base_url = paste(site, "/entity-model-prop-level-export", sep=""),
  ds = ds
)
#remove(df) #job finished? -- used later on for ordering process 

# County Features data
counties <- list()
counties$df <- ds$get('dh_feature', config=list(bundle='usafips'))

#----From Public Webpages----
# (shp) for US states & primary roads
## VA state used to be used to filter road data 
#roads <- list()
#roads$state <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/STATE/tl_2022_us_state.zip",
#                             filetype="shp", zip=TRUE)
#roads <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/PRIMARYROADS/tl_2022_us_primaryroads.zip",
#                          filetype="shp", zip=TRUE)

roads <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/PRISECROADS/tl_2022_51_prisecroads.zip",
                          filetype="shp", zip=TRUE)
# (csv) for US cities
#cities <- fread(paste0(getwd(), '/', 'USA_Major_Cities_GIS.csv')) 
cities <- fread(paste0(getwd(), '/', 'uscities.csv')) 
#rivr_maj <- read.csv("https://github.com/HARPgroup/HARParchive/raw/master/GIS_layers/MajorRivers.csv")
## note for rivr_maj: must use read.csv() so that we can apply process_geom() later
## fread() returned class ["data.table" "data.frame"] whereas read.csv() returns class ["data.frame"]

#Retrieving regional planning groups 
regions <- fread(paste0(getwd(), '/', 'Regions_ProposedReg_053122.csv'))
```

```{r Integrate Locality Geoms into their Regions}
## Processing and combining locality geometries into their regions 
counties_df <- counties$df # for sqldf
regions_geo <- sqldf( #adds geometries from counties df to the regions df
  "SELECT regions.*, counties_df.dh_geofield 
   FROM regions
   left outer join counties_df
   on (regions.county = counties_df.name)
   ")
rm(counties_df)
reg_split <- split(regions_geo, regions_geo$VMDWA_Reg2) #creates a new dataframe for each region containing the county names and geometries 
```

```{r One Joint Polygon Per Region}
## Combining the polygon geometries in each region df into 1 polygon for the whole region 
region_geom_list <- list() #create empty list where regional geometries will be stored 
for (i in 1:length(reg_split)) {
  reg_df <- as.data.frame(reg_split[i])
  reg_df <- na.omit(reg_df) #remove rows with NA geometry so loop doesn't fail
  colnames(reg_df) <- c("county","region", "dh_geofield")
  reg_name <- as.character(reg_df[1,2])
  reg_sf <- st_as_sf(reg_df, wkt = "dh_geofield")
  reg_geom_whole <- st_union(reg_sf) #combining locality polygons in the same region into 1 polygon
  region_geom_list[i] <- reg_geom_whole #create list containing all region geoms
  names(region_geom_list)[i] <- as.character(reg_name) #naming according to the region name 
}
```

# PROCESS Data
```{r PROCESS Data, echo=FALSE, warning=FALSE, message=FALSE}
#----General data organization----

# Full join facility model data & facility foundation data
## baseR merge() documentation says "all=TRUE" gives a full outer join by SQL terms
#facils$all <- merge(x=facils$mdat, y=facils$foundatn, by.x="featureid", by.y="Facility_hydroid", all=TRUE)

facils$all <- with(facils, sqldf("select foundatn.* , mdat.* from foundatn 
      left outer join mdat
      on (foundatn.Facility_hydroid = mdat.featureid)
      UNION
      select foundatn.* , mdat.* from mdat
      left outer join foundatn
      on (foundatn.Facility_hydroid = mdat.featureid)
      where foundatn.Facility_hydroid is null"
      ) ) 

colnames(facils$all) <- gsub("hydrocode", "facil_hydrocode", colnames(facils$all))


## To place rows with matches at the top:
#facils$all <- facils$all[order(facils$all$riverseg, na.last=TRUE),]

# Extract basin of user-input rivseg, from segs$all
segs$all$riverseg <- str_replace(segs$all$hydrocode, 'vahydrosw_wshed_', '') #prerequisite for fn_extract_basin()

# Legend title
legend_title <- legend_titling(metric, runid_list)

#- - - - - - - - - - -
# Filter roads to only Interstate, US Hwy, State Rte

#roads$state <- roads$state[roads$state$NAME=="Virginia", ] 
#roads <- st_intersection(roads, roads$state) #only VA primary roads

roads <- subset(roads, MTFCC=="S1100") #primary roads only
## keep only interstate, US hwy, or state Rte.

#change to sqldf
roads <- subset(roads, RTTYP=="I" | FULLNAME %in% grep("US Hwy.*", roads$FULLNAME, value=TRUE) | RTTYP=="S")

## shorten names to number only; column RTTYP gives classification I, U, or S
roads$FULLNAME <- mgsub(roads$FULLNAME, pattern=c("\\I- ", "US Hwy ", "State Rte "), replacement=c("","",""))
## remove any road followed by Bus, Byp, Alt, etc. by removing any row whose name still has a space
roads <- subset(roads, !(FULLNAME %in% grep(".* .*", roads$FULLNAME, value=TRUE)))

roads <- centroid_coords(roads, "geometry") #add centroid coords

#roads$sf <- subset(roads$sf, !(FULLNAME %in% grep(".* .*", roads$sf$FULLNAME, value=TRUE)))
#roads_sf <- roads$sf
#roads$sf <- sqldf("SELECT * FROM roads_sf WHERE 
#                  FULLNAME NOT LIKE '___%'")

# Filter/classify major cities & small towns
cities <- cities[cities$ST == 'VA',] #VA cities
## Remove city/town names that match their county/locality name

#update for new city csv
counties_df <- counties$df #needed for sqldf

#need to test to ensure this works properly in mapping
cities <- sqldf( 
  "SELECT cities.*  
   FROM cities
  where city is not (select counties_df.name from counties_df)"
)
remove(counties_df) #no longer needed

#not needed for new dataset, need to start new process  
# popul <- quantile(cities$population, probs = c(0.25, 0.5, 0.75)) 
# for(i in cities$population){
#   if(i < popul["75%"] & i > popul["50%"] | i < popul["25%"]){
#   cities <- cities[cities$population!=i,]
#   }
#   if(i >= popul["75%"]){
#   cities$class[cities$population==i] = "majC"
#   }
#   if(i <= popul["50%"] & i >= popul["25%"]){
#   cities$class[cities$population==i] = "town" #exclude smallest populations of 0-400
#   }
# }
#- - - - - - - - - - -

# Process Polygons; text-> spatial -> simple features
## counties
counties$sp <- process_geom(counties$df, "dh_geofield")
counties$sf <- st_as_sf(counties$sp)
counties$sf <- centroid_coords(counties$sf, "geometry")
st_crs(counties$sf) <- 4326
```

```{r bbox & facils by TYPE Param, warning=FALSE}
## Setting bbox variable based on what type of map we want 
# 'type' variable will either be: basin, locality, or region 

facils_all <- facils$all #create temporary df for use in sqldf for ordering
if (type == "basin") {
  
  for(i in rivseg){. #newly moved into this loop
  if(i==rivseg[1]){
    segs$basin <- fn_extract_basin(segs$all, i)
  }
  if(i!=rivseg[1]){
    segs$basin <- rbind(segs$basin, fn_extract_basin(segs$all, i))
  }
  }
  
  segs_basin <- segs$basin
  facils$basin <- sqldf("SELECT facils_all.* FROM facils_all WHERE riverseg IN (select segs_basin.riverseg from segs_basin) AND riverseg IS NOT NULL")
  #facils$basin <- subset(facils$all, riverseg %in% segs$basin$riverseg & riverseg!="NULL")
  # Filter out WSP entries (optional)
  facils$basin <- with(facils, sqldf("select * from basin where hydrocode not like 'wsp_%'") )
#facils$basin <- subset(facils$basin, 
                       #facil_hydrocode %in% grep("^wsp_", facils$basin$facil_hydrocode, value=TRUE, invert=TRUE) )
  # Order by largest metrics; then number them
  #facils$basin <- facils$basin[order(-facils$basin$metric_runid1, -facils$basin$metric_runid2),] #modified for new specific metric names
  facils_basin <- facils$basin #create temporary df for use in sqldf for ordering
  facils_basin <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_basin.*  
   FROM facils_basin 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
  facils$basin <- facils_basin 
  rm(facils_basin) #removing the ordered data frame since we're finished with it 
  facils$basin$NUM <- seq(1, nrow(facils$basin))
  sf_use_s2(FALSE) # switch off Spherical geometry
  bbox <- st_buffer(st_as_sfc(st_bbox(segs$basin_sf)), .05) #slightly past basin
  bbox <- st_bbox(bbox)
  facils$within <- facils$basin #generic name for facils within extent to be used by mapping fun 
}

if (type == "locality") {
  ## pull locality and geometry out of data frame with the locality parameter given
  locality_sf <- counties$sf[counties$sf$name == locality, ] #if REST IS working
  #filter to only facilities within the locality specified
  facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
  facils$all <- facils$all[!is.na(facils$all$Latitude),]
  facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  st_crs(facils$sf) <- 4326 
  st_crs(locality_sf) <- 4326 
  facils$within <- st_filter(facils$sf, locality_sf)
  
  #filter basins to those within the locality
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  segs$basin <- st_filter(segs$sf, locality_sf)
  segs$basin <- st_drop_geometry(segs$basin)
  
  ## order and number facils$within df based on metric
  coords <- st_coordinates(facils$within$geometry)
  colnames(coords) <- c("Longitude","Latitude")
  facils_within <- st_drop_geometry(facils$within) #create temporary df for use in sqldf for ordering
  facils_within <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_within.*  
   FROM facils_within 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
  facils$within <- facils_within 
  rm(facils_within) #removing the ordered data frame since we're finished with it 
  facils$within$NUM <- seq(1, nrow(facils$within))
  facils$within <- cbind(facils$within, coords)
  facils$within<- st_as_sf(facils$within, coords = c("Longitude","Latitude"))
  facils$within <- cbind(facils$within, coords)
  st_crs(facils$within) <- 4326
  facils$within <- st_drop_geometry(facils$within)
  
  sf_use_s2(FALSE) # switch off Spherical geometry
  bbox <- st_buffer(st_as_sfc(st_bbox(locality_sf)), .05) #slightly past basin
  bbox <- st_bbox(bbox)
}

if (type == "region") {
  #region geometries stored in region_geom_list under the region name 
  #pull region of interest given in params from list of region geometries 
  region_list <- region_geom_list[names(region_geom_list) == region]
  region_sf <- st_sfc(region_list) #create sf object from the region specified
  #region_sf <- st_as_sf(region_sf[1])
  st_crs(region_sf) <- 4326 #set coordinate system for spatial filtering 

  #filter basins to those within the region
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  segs$basin <- st_filter(segs$sf, region_sf)
  segs$basin <- st_drop_geometry(segs$basin)
  
  facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
  facils$all <- facils$all[!is.na(facils$all$Latitude),]
  facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  st_crs(facils$sf) <- 4326 

  facils$within <- st_filter(facils$sf, region_sf) #filter to MPs within the region

  ## need to order rows and add NUM column
  coords <- st_coordinates(facils$within$geometry)
  colnames(coords) <- c("Longitude","Latitude")
  facils_within <- st_drop_geometry(facils$within) #create temporary df for use in sqldf for ordering
  facils_within <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_within.*  
   FROM facils_within 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
  facils$within <- facils_within 
  rm(facils_within) #removing the ordered data frame since we're finished with it 
  facils$within$NUM <- seq(1, nrow(facils$within))
  facils$within <- cbind(facils$within, coords)
  facils$within<- st_as_sf(facils$within, coords = c("Longitude","Latitude"))
  facils$within <- cbind(facils$within, coords)
  st_crs(facils$within) <- 4326
  facils$within <- st_drop_geometry(facils$within)
  
  sf_use_s2(FALSE) # switch off Spherical geometry
  bbox <- st_buffer(st_as_sfc(st_bbox(region_sf)), .05) #slightly past basin
  bbox <- st_bbox(bbox)
}
rm(facils_all)
```

```{r, warning=FALSE}
## Process basin geometries

## don't duplicate riversegs for overlapping basins... 
## unless we wanted to show them in different colors? transparent overlap?
segs$basin <- segs$basin[!duplicated(segs$basin$riverseg),]

## basin watersheds
segs$basin_sp <- process_geom(segs$basin, "geom")
segs$basin_sf <- st_as_sf(segs$basin_sp)
st_crs(segs$basin_sf) <- 4326 #Set coord. reference syst.
# adding centroids to the basins for labeling -- using megans centroid function
segs$basin_sf <- centroid_coords(segs$basin_sf, "geometry") # new colnames for centroids: lng, lat
```

## SKIP unless VAhydro bbox is wanted

```{r VAhydro bbox if Desired, eval=FALSE}
## Retrieve bbox from vahydro property --- only run if this bbox is desired, otherwise skip 
for (i in 1:nrow(segs$basin)) {  #nrow used instead of length to overcome yesterday's error
 hid <- segs$basin$hydroid[i] 
 map <- RomProperty$new(ds, list(varkey="map", entity_type="dh_feature",featureid=hid),TRUE)
 extent <- RomProperty$new(ds, list(propname="extent", entity_type="dh_properties",featureid=map$pid),TRUE)
 extent_coords = ds$get_prop(config = list(featureid = extent$pid, entity_type='dh_properties'))
 extent_coords <- extent_coords[c('propname','propvalue')]
 extent_df <- data.frame(X = c(extent_coords[1,2], extent_coords[2,2]), Y = c(extent_coords[3,2], extent_coords[4,2]))
 bbox_ex <- st_buffer(st_as_sf(extent_df, coords = c("X","Y"), crs = 4326), .05)
 bbox_ex <- st_bbox(bbox_ex)
 assign("bbox", bbox_ex)
}
```

```{r Get NHD in bbox, message=FALSE}
# NHD data within the bbox
nhd  <- plot_nhdplus(bbox = bbox, actually_plot = FALSE)
```

```{r Labels df, warning=FALSE}
# River & stream labels
## major rivs = orders 5 & 6; streams = order 4
lb_rivr <- nhd$flowline[nhd$flowline$gnis_name!=' ' & #name!=blank & order 4, 5, or 6
                         (nhd$flowline$StreamOrde==6 | nhd$flowline$StreamOrde==5 | nhd$flowline$StreamOrde==4),] 
## no duplicate names; prioritize higher order names and then the longest segment of each duplicate
lb_rivr <- lb_rivr[order(-lb_rivr$StreamOrde, lb_rivr$gnis_name, -lb_rivr$LENGTHKM) & !duplicated(lb_rivr$gnis_name),]
## shorten long names
lb_rivr$gnis_name <- mgsub(lb_rivr$gnis_name, 
                             c('North Fork','South Fork','East Fork','West Fork','Middle Fork'), #pattern
                             c('NF','SF','EF','WF','MF')) #replacement
lb_rivr$StreamOrde <- mgsub(lb_rivr$StreamOrde, c(4,5,6), c("str","majR","majR"))
## calculate label coordinates
lb_rivr <- centroid_coords(lb_rivr, "geometry")

# Waterbody labels
lb_wtbd <- rbind(nhd$network_wtbd, nhd$off_network_wtbd)
## remove ones without names & filter to largest 25%
lb_wtbd <- lb_wtbd[!(lb_wtbd$gnis_name==' ' | lb_wtbd$gnis_name=='Noname') & lb_wtbd$AreaSqKM > quantile(lb_wtbd$AreaSqKM, 0.75),]
lb_wtbd <- centroid_coords(lb_wtbd, "geometry")
## Consider: move labeling of waterbodies to mapping function in order to filter by distance

#- - - - - - - - - - -

# Combine all labels into one df
#finish adjusting cities
#labels <- data.frame(
#  name= c(counties$sf$name, cities$city, lb_rivr$gnis_name, lb_wtbd$gnis_name, roads$FULLNAME[!duplicated(roads$FULLNAME)]),
#  class= c(counties$sf$ftype, cities$class, lb_rivr$StreamOrde, lb_wtbd$FTYPE, roads$RTTYP[!duplicated(roads$FULLNAME)]),
#  lng= as.numeric( c(counties$sf$lng, cities$lng, lb_rivr$lng, lb_wtbd$lng, roads$lng[!duplicated(roads$FULLNAME)]) ),
#  lat= as.numeric( c(counties$sf$lat,cities$lat, lb_rivr$lat, lb_wtbd$lat, roads$lat[!duplicated(roads$FULLNAME)]) )
#)
#remove(lb_rivr)
#remove(lb_wtbd)

# Columns for the aesthetics
## very specific function; just minimizing code lines:
#class_aes <- function(aesthetic){ #input values of an aesthetic to correspond with each label class
#  mgsub(labels$class, c("I","S","U","town","majC","LakePond","str","majR","county"), aesthetic)
#}
#labels$road <- class_aes( c(rep("yes",3), rep("no",6)) )

#labels$fontface <- class_aes( c(rep("plain",5),"bold","bold","bold","bold.italic") )
#labels$fontfam <- class_aes( c(rep("Comic Sans MS",3),"sans","sans",rep("serif",4) ) )
#labels$angle <- as.numeric( class_aes( c(0,0,0,0,0,15,15,15,0) ) ) #as.numeric() b/c mgsub() returns character strings
#labels$bg.r <- as.numeric( class_aes( c("NA","NA","NA",.05,.05,.1,.1,.05,.03) ) )
#labels$segsize <- as.numeric( class_aes( c("NA","NA","NA",.5,.5,.5,.5,.75,1) ) )

#textcol <- c("red","white","black","deepskyblue4","#003333") #c(I, S, U/town/majC, LakePond/str/majR, county)
#labels$segcol <- class_aes( c("NA","NA","NA", textcol[c(3,3,4,4,4,5)] ) )
#labels$colcode <- class_aes( c(1,2,3,3,3,4,4,4,5) ) #corresponds to textcol for the color scale

#labels$sizecode <- as.numeric ( class_aes( c(1,1,1,2,2,2,2,3,4) ) ) #corresponds to textsize for the size scale

#label_fill <- c("blue","#0B5F14","white") #for road bubbles c(I,S,U)
#labels$fill <- class_aes( c(1,2,3, rep("NA",6) ) )

```

```{r Labels df Using mapstyle_config}
labels <- list()
labels$aes <- styles$custom

labels$data <- data.frame(
  name= c(counties$sf$name, cities$city, lb_rivr$gnis_name, lb_wtbd$gnis_name, roads$FULLNAME[!duplicated(roads$FULLNAME)]),
  class= c(counties$sf$ftype, cities$class, lb_rivr$StreamOrde, lb_wtbd$FTYPE, roads$RTTYP[!duplicated(roads$FULLNAME)]),
  lng= as.numeric( c(counties$sf$lng, cities$lng, lb_rivr$lng, lb_wtbd$lng, roads$lng[!duplicated(roads$FULLNAME)]) ),
  lat= as.numeric( c(counties$sf$lat,cities$lat, lb_rivr$lat, lb_wtbd$lat, roads$lat[!duplicated(roads$FULLNAME)]) )
)

labels$full <- with(labels, sqldf("select data.* , aes.* from data 
      left outer join aes
      on (data.class = aes.class)
    "
))

# UNFINISHED integration into fn_mapgen()
labels <- labels$full
labels <- labels[ ,!duplicated(colnames(labels))]


textcol <- colors$default$text
label_fill <- colors$default$fill
```

```{r}
## Putting the metric data into bins for ranged legend for map
facils_within <- facils$within
mp_layer_sql <- paste('SELECT *, ',df$runlabel[1],' AS demand_metric
                         FROM facils_within'
                         , sep="")
  
mp_layer <- sqldf(mp_layer_sql)
metric_unit <- substr(metric, nchar(metric) - 2, nchar(metric))  #get metric unit from last 3 characters of metric name
wd_mgd = c(0.5,1.0,2,5,10,25,50,100,1000) #set ranges for the bins 
wd_mgy = c(1, 5,10, 20,50, 100, 1000, 5000, 10000)
if (metric_unit == "mgd") { #different ranges for mgd and mgy
  div <- wd_mgd
} else if (metric_unit == "mgy") {
  div <- wd_mgy
}

#Adding bin column to dataframe based on range which data falls into
bins_sql <-  paste("SELECT *,
	                  CASE WHEN demand_metric <= ",div[1]," THEN '1'
		                WHEN demand_metric >  ",div[1]," AND demand_metric <= ",div[2]," THEN '2'
		                WHEN demand_metric >  ",div[2]," AND demand_metric <= ",div[3]," THEN '3'
		                WHEN demand_metric >  ",div[3]," AND demand_metric <= ",div[4]," THEN '4'
		                WHEN demand_metric >  ",div[4]," AND demand_metric <= ",div[5]," THEN '5'
		                WHEN demand_metric > ",div[5]," AND demand_metric <= ",div[6]," THEN '6'
		                WHEN demand_metric > ",div[6]," AND demand_metric <= ",div[7]," THEN '7'
		                WHEN demand_metric > ",div[7]," AND demand_metric <= ",div[8]," THEN '8'
		                WHEN demand_metric > ",div[8]," AND demand_metric <= ",div[9]," THEN '9'
		                WHEN demand_metric > ",div[9]," THEN '10'
		                ELSE '0'
		                END AS bin
		                FROM mp_layer",sep="")

mp_layer <- sqldf(bins_sql)  

#change column name back to the specific metric
names(mp_layer)[names(mp_layer) == 'demand_metric'] <- df$runlabel[1]

#remove duplicated columns
mp_layer <- mp_layer[, !duplicated(colnames(mp_layer))]

#make sure bin column is type numeric for sizing data points 
class(mp_layer$bin) <- "numeric"
```

```{r Apply fn_mapgen, warning=FALSE, message=FALSE}
fn_mapgen(type, metric, rivseg, bbox, segs, counties, roads, nhd, labelsP, locality, region, mp_layer, metric_unit) #execute mapping function
```

```{r Save PNG, echo=FALSE }
# Saving map as a png
ggsave(
  filename = paste(export_path, map_name, ".png", sep=""),
  plot = map,
  width = 25,
  height = 20
  )
```

#Create Table Data
``` {r Create Table Data, warning=FALSE, message=FALSE }

# - - - - creating initial data frame  - - - -
table <- data.frame(Number= facils$basin$NUM, 
                        Facility=facils$basin$Facility, 
                        Source_Type = facils$basin$`Source Type`,
                        Source = facils$basin$`MP Name`,
                        Rivseg= facils$basin$riverseg,
                        Locality = facils$basin$Locality, 
                        fiveYr= facils$basin$fiveyr_avg_mgy
                        ) 

# - - - - add rivseg names- - - - - -

for(i in 1:nrow(table)){ 
    loc_rivseg <- (segs$basin[grep(facils$basin$riverseg[i], segs$basin$riverseg),])
    table$rivsegName[i]  <- loc_rivseg$name 
}


# #- - - -add upstream or downstream - - - removed for now, not priority
# 
# #needs to be adjusted 
# for(i in 1:nrow(facils$basin)){ 
#   if(facils$basin$riverseg[i] == rivseg)
#   {
#     up_down<- "Upstream"
#     table$Upstream_Downstream[i] <- up_down
#   }
#   else if (facils$basin$riverseg[i] != rivseg)
#   {
#     up_down <- "Downstream"
#     table$Upstream_Downstream[i] <- up_down
#   }
# }

#- - - - add permitted capacity - - -

for (i in 1:nrow(facils$basin)){
  systemObj <- RomProperty$new(ds,list(
    featureid = facils$basin$featureid[i],
    propcode= "vahydro-1.0"), 
  TRUE)
  permCapac <- RomProperty$new(ds,list(
  featureid = systemObj$pid,
  propname = 'vwp_max_mgy'),
  TRUE)
  table$vwp_max_mgy[i] <- permCapac$propcode  
}

#Replace zeros with "no permit"
table$vwp_max_mgy <-  replace(table$vwp_max_mgy, table$vwp_max_mgy==0, "No Permit")

#- - - - add 5 yr avg use (MGY) with wd current- PER FACILITY - - -

# for (i in 1:nrow(facils$basin)){
# val <- RomProperty$new(ds,list(
#     featureid= facils$basin$featureid[i],
#     propname= "wd_current_mgy"), 
#   TRUE)
# five_mgy <- val$propvalue
# table$five_mgy[i] <- round(five_mgy,2)
# }

#- - -  5 year avg PER SOURCE - - - 

#what 5 years should we be using 
#why are the numbers sometimes very different

#for (i in 1:nrow(facils$basin)){
#  fiveavg <- mean(na.omit(facils$basin$'2022'[i],facils$basin$'2021'[i],facils$basin$'2020'[i],facils$basin$'2019'[i],facils$basin$'2018'[i], na.rm= TRUE))
#  table$five_mgy_new[i] <- round(fiveavg, 2)
#}

#table$five_mgy_new <- facils$basin$fiveyr_avg_mgy_2

colnames(table)[2] <- "Facility Name"
colnames(table)[1] <- "Number"
colnames(table)[3] <- "Source Type"
colnames(table)[4] <- "Source Name"
colnames(table)[5] <- "River Segment"
colnames(table)[8] <- "River Segment Names"
colnames(table)[6] <- "County"
#colnames(table)[Upstream_Downstream] <- "Upstream Vs. Downstream"
colnames(table)[9] <- "Permitted Capacity(MGY)"
colnames(table)[7] <- "5 Year Avg Use(Source MGY)"

   
```
# Call Table 
``` {r Call Table, echo= False, warning= False}
fn_tablegen(table)
```