---
title: "Mapping Workflow"
author: "HARP Analysts"
date: "`r Sys.Date()`"
output: html_document
params:
  ## More params used during development and testing for user-control -- will be consolidated  
  rivseg: ["JL6_7430_7320"] #["JL6_7320_7150","JL6_6890_6990","JL6_7430_7320","JA2_7410_7470", "JA4_7280_7340","JB3_6820_7053"] 
  locality: ["Spotsylvania"]
  region: ["Shenandoah_2"]    
  type: ["facility"] #either 'source' or 'facility', depending on level of map and table wanted 
  model_version: ["vahydro-1.0"]
  runid_list: [ "runid_11", "runid_13" ] # Use runid_11 and runid_13 in that order for 2020 vs 2040 table.  Ignored if metric_type = "measured"
  metric: ["wd_mgd"] # 5-year avg metric called 'fiveyr_avg_mgy' , which is part of foundational data frame
  metric_type: ["modeled"] #either 'modeled' or 'measured'. Measured metric(s) already in foundational data. Modeled pulls VAhydro 
  map_type: ["locality"] #should be one of: basin, locality, or region ; depending on what map type is desired 
  bbox_type: ["auto"] #either 'auto' or 'vahydro'. vahydro map type only functional for segments 
  ## To to map 5-yr avg use, type can be either facility or source, metric must be fiveyr_avg_mgy, metric type must be measured
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(hydrotools)
library(mgsub)
library(sp)
library(rgeos)
library(sf)
library(nhdplusTools)
library(ggmap)
library(raster)
library(ggplot2)
library(ggnewscale)   
library(ggsn)
library(ggspatial)
library(ggrepel)
library(flextable)
library(geosphere)
#library(tidycensus)
basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new(site, rest_uname)
ds$get_token(rest_pw)
```

```{r UserInputs, echo=FALSE}
rivseg <- params$rivseg #for mapping extent of basin(s)
locality <- params$locality #for mapping extent of a locality
region <- params$region #for mapping extent of a region 
type <- params$type #for map & table to indicate source-level or facility-level
model_version <- params$model_version
runid_list <- params$runid_list
metric <- params$metric
metric_type <- params$metric_type
#map_name <- params$map_name
map_type <- params$map_type
bbox_type <- params$bbox_type
```

# Get functions from other locations 
```{r Analysts: Load External Functions, echo=FALSE}
## For analysts, updated on each save
source(paste0(getwd(), '/', 'fn_mapgen_est.R' )) #load mapping function
source(paste0(getwd(), '/', 'mapstyle_config.R' )) #load mapping aesthetics
source(paste0(getwd(), '/', 'fn_tablegen.R' )) #load table function
source(paste0(getwd(), '/', 'fn_labelprep.R' )) #load labeling function
```
  OR
```{r Planners: Load Functions from Online, echo=FALSE, eval=FALSE}
## For planners, updated when changes are merged to master
source("https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/fn_mapgen_est.R") #load mapping function
source("https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/mapstyle_config.R") #load mapping aesthetics
source("https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/fn_tablegen.R") #load table function
source("https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/fn_labelprep.R") #load labeling function
```

```{r Establish Functions, echo=FALSE}
# Read data that requires file download
download_read <- function(url, filetype, zip) {
  localpath <- tempdir()
  filename <- basename(url)
  filepath <- paste(localpath,"\\", filename, sep="")

  download.file(url, filepath)
  
  if(zip==TRUE){
   folder <- unzip(filepath, exdir=localpath)
   filepath <- grep(".*.csv.*", folder, value=TRUE)
  }
  if(filetype=="csv"){
    df <- read.csv(file=filepath, header=TRUE, sep=",")
  }
  if(filetype=="shp"){
    layer <- gsub("\\.zip", "", filename)
    df <- read_sf(dsn=localpath, layer=layer)
  } 
  if(filetype!="csv" & filetype!="shp"){
    message(paste("Error in download_read(): filetype must be 'csv' or 'shp'"))
  }
  return(df)
}
#- - - - - - - - - - -

# Convert any data frame w/ geometry stored as Well Known Text to "SpatialXxxDataFrame" (Xx_sp)
## Specify the data frame and the character name of the geometry column
process_geom <- function(data, geom_col) {
  for (i in 1:nrow(data)) {
    sp.i <- sp::addAttrToGeom(
      x=readWKT(data[i,geom_col]), 
      y=as.data.frame(as.list(subset(data[i,],select=-c(names(data)==geom_col)))),      
      match.ID=TRUE
    )
    if (i == 1) {
      # start with one 
      data_sp <- sp.i
    } else {
      # append
      data_sp <- rbind(data_sp, sp.i)
    }
  }
  return(data_sp)
}
#- - - - - - - - - - -

# Add centroid coords to a data frame
centroid_coords <- function(data, geom_col) {
  
  #NEW:
  if( length(grep("sfc", lapply(data, class)))==0 ){
    data <- process_geom(data, geom_col)
    data <- st_as_sf(data)
  } #.
  
  for (r in 1:nrow(data)) { #get centroid coord. for labeling
    centroid <- st_centroid(data[r, geom_col])
    centroid <- as.data.frame(st_coordinates(centroid))
    data$lng[r] <- centroid$X
    data$lat[r] <- centroid$Y
  }
  
  #NEW:
  #st_crs(data) <- 4326
  #.
  return(data)
}
#- - - - - - - - - - -

# Generate user-understandable legend titles
## Kept up here as a function so that it's easy to add if-statements when user-input options expand
legend_titling <- function(metric, runid_list){
  if(metric=="wd_mgd"){
    name <- "Withdrawal"
    unit <- "(MGD)"
    legend_title <- runid_list
    year <- mgsub(runid_list, c("runid_11","runid_13"), c("2020","2040"))
  for(i in 1:length(runid_list)){
    legend_title[i] <- paste(year[i],name,unit,sep="\n")
  }
  }
  if(metric=="fiveyr_avg_mgy"){ #this metric isn't associated w a runid
    name <- "5-yr Avg Use"
    unit <- "(MGY)"
    legend_title<- paste(name,unit,sep="\n")
  }
  return(legend_title)
}
```

# Get Foundational Data
```{r Analysts: From wd var, set in config}
facils <- list() #create empty list to store dfs
# the variable "github_location" should in in config.local and provides easy access to these resources.  Thus, no need to change code here, rather, the user changes their own config.
furl = paste0(github_location, "/Foundational_Data/2023/foundation_dataset_mgy_2018-2022_5ya.csv")
facils$foundatn <- fread(furl) # Foundational sources/MP data

```
  OR
```{r Planners: use setwd, eval =FALSE}
## OR, set your working directory (setwd) to the location of the foundational csv, with the name above ^ and run:
facils <- list() #create empty list to store dfs
facils$foundatn <- fread(paste0(getwd(),'/foundation_dataset_mgy_2018-2022_5ya.csv'))
```

# PULL Data 
```{r PULL Data, echo=FALSE, message=FALSE, warning=FALSE}
#----From VAhydro----
#segs$all <- ds$get('dh_feature', config=list(ftype='vahydro',bundle='watershed')) ##gives errors
segs <- list()
segs$all <- download_read(url=paste(site,"/vahydro_riversegs_export",sep=""), filetype="csv", zip=FALSE) # All vahydro watershed features
# note: potential NULLs for newly carved data
counties <- list() # County Features data
counties$df <- ds$get('dh_feature', config=list(bundle='usafips'))

#----From Public Webpages----
roads <- download_read(url="https://www2.census.gov/geo/tiger/TIGER2022/PRISECROADS/tl_2022_51_prisecroads.zip",
                          filetype="shp", zip=TRUE) # (shp) for US states & primary roads
cities <- fread('https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/USA_Major_Cities_GIS.csv') # prev uscities.csv, (csv) for US cities

# --From Github--
regions <- fread('https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/Regions_ProposedReg_053122.csv') #Retrieving regional planning groups 
#facilities_df <- fread('https://github.com/HARPgroup/HARParchive/raw/master/HARP-2023-Summer/facilities_all_geom.csv')
facilities_df <- fread(paste0(getwd(),'/facilities_all_geom.csv')) #created with VAhydro facility feature data 
#rivr_maj <- read.csv("https://github.com/HARPgroup/HARParchive/raw/master/GIS_layers/MajorRivers.csv")
```


# Geom Processing
```{r Region Geom Processing}
## Processing and combining locality geometries into their regions 
## Columns from vahydro have different names as of 7/10:
names(counties$df)[names(counties$df) == 'dh_geofield.geom'] <- "dh_geofield"
counties_df <- counties$df # for sqldf


regions_geo <- sqldf( #adds geometries from counties df to the regions df
  "SELECT regions.*, counties_df.dh_geofield 
   FROM regions
   left outer join counties_df
   on (regions.county = counties_df.name)
   ")
rm(counties_df)
reg_split <- split(regions_geo, regions_geo$VMDWA_Reg2) #creates a new dataframe for each region containing the county names and geometries 

## Combining the polygon geometries in each region df into 1 polygon for the whole region 
region_geom_list <- list() #create empty list where regional geometries will be stored 
for (i in 1:length(reg_split)) {
  reg_df <- as.data.frame(reg_split[i])
  reg_df <- na.omit(reg_df) #remove rows with NA geometry so loop doesn't fail
  colnames(reg_df) <- c("county","region", "dh_geofield")
  reg_name <- as.character(reg_df[1,2])
  reg_sf <- st_as_sf(reg_df, wkt = "dh_geofield")
  reg_geom_whole <- st_union(reg_sf) #combining locality polygons in the same region into 1 polygon
  region_geom_list[i] <- reg_geom_whole #create list containing all region geoms
  names(region_geom_list)[i] <- as.character(reg_name) #naming according to the region name 
}
```

```{r Facility Geom Processing}
## Need to remove facilities without a geometry -- can't be mapped without coords
facilities_df <- facilities_df[-which(facilities_df$dh_geofield == ""), ] #removes approx 125 rows
facilities_sf <- st_as_sf(facilities_df, wkt = "dh_geofield")
coords <- st_coordinates(facilities_sf$dh_geofield)
colnames(coords) <- c("Longitude","Latitude")
facilities_df <- cbind(facilities_df, coords) #add coordinates to facilities df
```

# PROCESS Data
```{r PROCESS Data, echo=FALSE, warning=FALSE, message=FALSE}
#----General data organization----
segs$all$riverseg <- str_replace(segs$all$hydrocode, 'vahydrosw_wshed_', '') #prerequisite for fn_extract_basin()

#modify colnames in foundational df
names(facils$foundatn)[names(facils$foundatn) == 'Source Type'] <- 'Source_Type'
names(facils$foundatn)[names(facils$foundatn) == 'MP Name'] <- 'MP_Name'
names(facils$foundatn)[names(facils$foundatn) == 'Use Type'] <- 'Use_Type'

#----Roads----
# Filter roads to only Interstate, US Hwy, State Rte:
#roads <- st_intersection(roads, roads$state) #only VA primary roads
roads <- subset(roads, MTFCC=="S1100") #primary roads only
## keep only interstate, US hwy, or state Rte:
roads <- subset(roads, RTTYP=="I" | FULLNAME %in% grep("US Hwy.*", roads$FULLNAME, value=TRUE) | RTTYP=="S")
## shorten names to number only; column RTTYP gives classification I, U, or S
roads$FULLNAME <- mgsub(roads$FULLNAME, pattern=c("\\I- ", "US Hwy ", "State Rte "), replacement=c("","",""))
## remove any road followed by Bus, Byp, Alt, etc. by removing any row whose name still has a space
roads <- subset(roads, !(FULLNAME %in% grep(".* .*", roads$FULLNAME, value=TRUE)))
roads <- centroid_coords(roads, "geometry") #add centroid coords

#-----Counties----
# Process counties polygons; text-> spatial -> simple features
counties$sp <- process_geom(counties$df, "dh_geofield")
counties$sf <- st_as_sf(counties$sp)
counties$sf <- centroid_coords(counties$sf, "geometry")
st_crs(counties$sf) <- 4326

#----Cities----
# Remove city/town names that match their county/locality name
counties_df <- counties$df #needed for sqldf
cities <- sqldf("SELECT cities.* 
                FROM cities 
                WHERE NAME 
                NOT IN (select counties_df.name from counties_df) 
                ")
remove(counties_df) #no longer needed
cities <- cities[cities$ST == 'VA',] #VA cities
cities <- sqldf("SELECT * FROM cities WHERE CLASS is not 'Census Designated Place' ")
cities <- sqldf("SELECT * FROM cities WHERE POPULATION> '400' ")
```

#Pull Metric Data
```{r Create df for Runs & Metric}
#create df with run info and metric data, to be used in vahydro data retrieval
if (metric_type == "modeled") {
  df <- data.frame(runid=runid_list, model_version, metric=metric)
    for(i in 1:length(runid_list)){
      df$runlabel[i] <- paste0(runid_list[i], '_', metric)
    } 
  } else if (metric_type == "measured") {
  df <- data.frame(metric=metric, runlabel=metric)
}
```

```{r Facility-Level Metric Data, warning=FALSE, message=FALSE}
## For mapping by facility  
if (type == "facility") {
 if (metric_type == "modeled") { 
  facil_featr <- om_vahydro_metric_grid( # pulling facilities and the metric of interest
    metric=FALSE, runids=df, featureid='all', 
    entity_type='dh_feature', bundle='facility',
    ftype='all', model_version = model_version,
    base_url = "http://deq1.bse.vt.edu/d.dh/entity-model-prop-level-export",
    ds = ds)
  facil_featr <- sqldf("SELECT * 
                      FROM facil_featr 
                      WHERE hydrocode not like 'wsp_%'")  # Filter out WSP entries
 #Get facility coordinates -- already in facilities df 
 facils$all <- sqldf("SELECT a.*, b.Longitude, b.Latitude, b. Locality
                      FROM facil_featr as a
                      LEFT OUTER JOIN facilities_df as b
                      ON (a.hydrocode = b.hydrocode)" ) 
 } else if (metric_type =="measured") {
   facils_foundatn <- facils$foundatn
   facils_sql <- paste('SELECT *, ',df$runlabel[1],' as metric
                         FROM facils_foundatn'
                         , sep="")
  
   facils_foundatn <- sqldf(facils_sql)
   # aggregate and sum source data using sqldf:
   facils_foundatn <- sqldf("select facils_foundatn.*,
                     sum(metric) as sum
                     from facils_foundatn
                     group by Facility_hydroid")
   facils_foundatn <- facils_foundatn[ , !names(facils_foundatn) == df$runlabel[1]]
   names(facils_foundatn)[names(facils_foundatn) == 'sum'] <- df$runlabel[1]
   facils_foundatn <- facils_foundatn[, !duplicated(colnames(facils_foundatn))]
   #Get facility coordinates
   facil_bind <- sqldf("SELECT a.*, b.Longitude, b.Latitude, b.Locality
                      FROM facils_foundatn as a
                      LEFT OUTER JOIN facilities_df as b
                      ON (a.Hydrocode = b.hydrocode)" )
   
  facils$all <- facil_bind
 }
}
## Coords previously gotten w/:
#   for(i in 1:nrow(facils$found_each)){ #takes a couple minutes
#    facil.i <- RomFeature$new(ds,list(hydroid=facils$found_each$Facility_hydroid[i]), TRUE)
#    facils$found_each$dh_geofield[i] <- facil.i$geom
#  } # adds point geometry for each facility
```

```{r Source-Level Data Prep}
if (type == "source") {
  if (metric_type == "modeled") {
    print('No usability with any source-level modeled metrics yet, change params')
  } else if (metric_type == "measured") {
  facils$all <- facils$foundatn
  }
} 
```

```{r Riverseg if Needed}
## Adding riversegs to data frame when not present using a spatial join
# Note: this is not a totally robust method & will be changed before development is finished 
# first, check if riverseg exists. It will already be in table if model data was pulled & joined 
facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
facils$all <- facils$all[!is.na(facils$all$Latitude),]

 if (!"riverseg" %in% colnames(facils$all)) { # TRUE when riverseg column not present, will execute loop
  facils$all <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes several seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  st_crs(facils$all) <- 4326
  # do spatial join to determine which seg each source/facility is in
  spat_join <- st_join(facils$all, segs$sf) #riverseg column added, polygons in col geom
  coords <- st_coordinates(spat_join$geometry)
  colnames(coords) <- c("Longitude","Latitude")
  spat_join <- spat_join[ , !names(spat_join) == "geom"]
  spat_join <- st_drop_geometry(spat_join)
  facils$all <- spat_join
  facils$all <- cbind(facils$all, coords)
  colnames(facils$all) <- gsub("hydrocode", "rseg_hydrocode", colnames(facils$all))
}
```

```{r (New) Filter data by extent of segs}
#Filter sources/facilities by segs within extent
#facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
facils_all <- st_drop_geometry(facils$all) #create temporary df for use in sqldf for ordering
#st_crs(facils$sf) <- 4326 

if (map_type == "basin") { #'type' variable will either be: basin, locality, or region 
  for(i in rivseg){. #newly moved into this loop
    if(i==rivseg[1]){
    segs$basin <- fn_extract_basin(segs$all, i)
    }
    if(i!=rivseg[1]){
    segs$basin <- rbind(segs$basin, fn_extract_basin(segs$all, i))
    }
  }
} else if (map_type =="locality") {
  locality_sf <- counties$sf[counties$sf$name == locality, ] #if REST IS working
  #locality_sp <- process_geom(as.data.frame(locality_sf), "dh_geofield") #for reverse-fill process for map 
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  #segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  #rm(segs_all)
  segs$sf <- st_as_sf(segs_all, wkt = "geom")
  st_crs(segs$sf) <- 4326
  sf_use_s2(FALSE)
  segs$basin <- st_filter(segs$sf, locality_sf) #filter basins by locality
  #segs$basin <- st_drop_geometry(segs$basin)
} else if (map_type == "region") {
  region_list <- region_geom_list[names(region_geom_list) == region]
  region_sf <- st_sfc(region_list) #create sf object from the region specified
  region_sfd <- st_as_sf(region_sf) #for region_sp
  segs$region_sf <- region_sfd # for darker outline around region
  st_crs(segs$region_sf) <- 4326
  region_sp <- as_Spatial(region_sfd, cast = FALSE)
  st_crs(region_sf) <- 4326 #set coordinate system for spatial filtering 
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  sf_use_s2(FALSE)
  segs$basin <- st_filter(segs$sf, region_sf) #filter basins by the region
  #segs$basin <- st_drop_geometry(segs$basin)
}

segs_basin <- st_drop_geometry(segs$basin)
#segs$basin_sp <- process_geom(segs$basin, "geom")
segs$basin_sf <- st_as_sf(segs$basin, wkt = "geom")
st_crs(segs$basin_sf) <- 4326 
facils_basin <- facils$basin #create temporary df for use in sqldf for orderin
facils_all <- facils_all[,colSums(is.na(facils_all))<nrow(facils_all)]

facils$basin <- sqldf("SELECT facils_all.* 
                          FROM facils_all 
                          WHERE riverseg 
                          IN (select segs_basin.riverseg from segs_basin) 
                          AND riverseg IS NOT NULL")
facils$within <- with(facils, sqldf("SELECT * 
                                     FROM basin 
                                     WHERE hydrocode not like 'wsp_%'") )  # Filter out WSP (optional)
 #Ordering & Numbering data
facils_within <- st_drop_geometry(facils$within) #create temporary df for use in sqldf for ordering
facils_within <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_within.*  
  FROM facils_within 
  ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
facils$within <- facils_within 
rm(facils_within) #removing the ordered data frame  
facils$within$NUM <- seq(1, nrow(facils$within))
```


```{r Process Basin Geom & Bbox, warning=FALSE}
segs$basin <- segs$basin[!duplicated(segs$basin$riverseg),] # don't duplicate riversegs for overlapping basins
if (map_type == "locality" || map_type == "region") {
   #segs$basin_sp <- process_geom(segs$basin, "geom")
  segs$basin_sf <- st_as_sf(segs$basin, wkt = "geom")
  st_crs(segs$basin_sf) <- 4326 #Set coord. reference syst.
}
segs$basin_sf <- centroid_coords(segs$basin_sf, "geom") # new colnames for centroids: lng, lat
#segs$basin_sp <- process_geom(segs$basin_sf, "geom") #sp object used in mapping
# Create bbox
sf_use_s2(FALSE) # switch off Spherical geometry
bbox <- st_buffer(st_as_sfc(st_bbox(segs$basin_sf)), .02) #slightly past basin
bbox <- st_bbox(bbox)
```

```{r VAhydro bbox if Desired, eval=FALSE}
## Retrieve bbox from vahydro property --- only run if this bbox is desired, otherwise skip 
# only operational for river segments/basins
if (bbox_type == "vahydro") {
  for (i in 1:nrow(segs$basin)) { 
  hid <- segs$basin$hydroid[i] 
  map <- RomProperty$new(ds, list(varkey="map", entity_type="dh_feature",featureid=hid),TRUE)
  extent <- RomProperty$new(ds, list(propname="extent", entity_type="dh_properties",featureid=map$pid),TRUE)
  extent_coords = ds$get_prop(config = list(featureid = extent$pid, entity_type='dh_properties'))
  extent_coords <- extent_coords[c('propname','propvalue')]
  extent_df <- data.frame(X = c(extent_coords[1,2], extent_coords[2,2]), Y = c(extent_coords[3,2], extent_coords[4,2]))
  bbox_ex <- st_buffer(st_as_sf(extent_df, coords = c("X","Y"), crs = 4326), .05)
  bbox_ex <- st_bbox(bbox_ex)
  assign("bbox", bbox_ex)
  }
}
```

```{r Get NHD Data within in bbox, message=FALSE}
# NHD data within the bbox
nhd  <- plot_nhdplus(bbox = bbox, actually_plot = FALSE)
```

```{r Labeling & Mapping Prep, warning=FALSE}
## ALL labeling now done in this chunk
legend_title <- legend_titling(metric, runid_list)
textcol <- colors$default$text #still needed for mapping
label_fill <- colors$default$fill #still needed for mapping
rm(maplabs)
maplabs <- fn_labelprep(data=list(counties$sf, cities, roads, nhd), classes=c("county","city","road","nhd"))
```

```{r Metric Unit Processing}
metric_unit <- substr(metric, nchar(metric) - 2, nchar(metric))  #get metric unit from last 3 characters of metric name
wd_mgd = c(0.5, 1.0, 2, 10, 25, 100, 1000) #set ranges for the bins 
wd_mgy = c(1, 5, 10, 50, 250, 1000, 10000)
if (metric_unit == "mgd") { #different ranges for mgd and mgy
  div <- wd_mgd
} else if (metric_unit == "mgy") {
  div <- wd_mgy
}
```

```{r Metric Legend Bins}
facils$within <- facils$within[,colSums(is.na(facils$within))<nrow(facils$within)] #for extra long & lat columns full of NAs
names(facils$within)[names(facils$within) == 'Longitude.1'] <- 'Longitude' #rename coord cols 
names(facils$within)[names(facils$within) == 'Latitude.1'] <- 'Latitude'
facils_within <- facils$within

mp_layer_sql <- paste('SELECT *, ',df$runlabel[1],' AS demand_metric
                      FROM facils_within' , sep="")
mp_layer <- sqldf(mp_layer_sql)
bins = as.data.frame(div)
bins$classid <- index(bins)
names(bins) <- c("val", "bin")

entity_classes <- sqldf(
  "select a.NUM, min(b.bin) as bin
  from mp_layer as a 
  left outer join bins as b 
  on (a.demand_metric < b.val) 
  group by a.NUM" )
mp_layer <- sqldf(
  "select a.*, b.bin 
  from mp_layer as a 
  left outer join entity_classes as b 
  on a.NUM = b.NUM " )

mp_layer$bin[is.na(mp_layer$bin)] <- "X" # replacing NA values in bin column
names(mp_layer)[names(mp_layer) == 'demand_metric'] <- df$runlabel[1] #change column name back to the specific metric
mp_layer <- mp_layer[, !duplicated(colnames(mp_layer))] #remove duplicated columns
```


```{r Apply fn_mapgen, warning=FALSE, message=FALSE}
# execute mapping function
# args/params have been kept separate during dev. so far, but will be consolidated & some removed once we're happy with maps 
fn_mapgen(type, map_type, style, metric, rivseg, bbox, segs, counties, roads, 
          nhd, maplabs, locality, region, mp_layer, metric_unit)

# Error in if (distance > 300) { : missing value where TRUE/FALSE needed
# Solution: this indicates the bbox is not in the format needed by the function. Regenerate the bbox and make sure it is of class bbox and has names xmin, xmax, etc.
```

```{r Set Map Name}
if (map_type == "basin") {
  map_name <- rivseg
} else if (map_type == "locality") {
  map_name <- locality
} else if (map_type == "region") {
  map_name <- region
}

if (type == "source") {
  map_name <- paste0(map_name, '_sources')
} else if (type == "facility") {
  map_name <- paste0(map_name, '_facils')
}
```

```{r Save PNG, echo=FALSE }
# Saving map as a png
ggsave(
  filename = paste(export_path, map_name, ".png", sep=""),
  plot = map,
  width = 25,
  height = 20
  )
# export_path set in config for analysts, set in console if nonexistent to location where map will be exported 
```

#Create Table
``` {r Source-Level Table, warning=FALSE, message=FALSE}
if (type=="source"){
  table <- data.frame(Number= facils$within$NUM, 
                        Facility=facils$within$Facility, 
                        Source_Type = facils$within$Source_Type,
                        Source = facils$within$MP_Name,
                        Rivseg= facils$within$riverseg,
                        Locality = facils$within$Locality, 
                        fiveYrAvg_mgy= facils$within$fiveyr_avg_mgy #might need to get rid of this and change it just into whatever metric is required
                        ) 

  # - - - - add rivseg names- - - - - -
  for(i in 1:nrow(table)){ 
    loc_rivseg <- (segs$basin[grep(facils$within$riverseg[i], segs$basin$riverseg),])
    if (nrow(loc_rivseg) != 0) {
      table$rivsegName[i] <- loc_rivseg$name
    } else { # if no matching row was found for the riverseg ID, leave blank but don't break
      table$rivsegName[i] <- ""
      }
  }
  #- - - - add permitted capacity - - - permitted capacity @ source level disabled for now  
#  for (i in 1:nrow(facils$within)){
#    systemObj <- RomProperty$new(ds,list(
#    featureid = facils$within$featureid[i], ## featureid won't exist in source-level data since model data wasn't joined 
#    propcode= "vahydro-1.0"), 
#    TRUE)
#    permCapac <- RomProperty$new(ds,list(
#    featureid = systemObj$pid,
#    propname = 'vwp_max_mgy'),
#    TRUE)
#    table$vwp_max_mgy[i] <- permCapac$propcode  
#  }
  #Replace zeros with "no permit"
#  table$vwp_max_mgy <-  replace(table$vwp_max_mgy, table$vwp_max_mgy==0, "No Permit")

 #Re-order columns
  table <- table[,c(1:2,4,3,6,8,5,7)]
  #Set column names 
  colnames(table)[4] <- "Source Type"
  colnames(table)[6] <- "River Segment Name"
  colnames(table)[7] <- "River Segment ID"
  colnames(table)[8] <- "5-yr Avg Use (mgy)"
} else if (type=="facility"){
  if (metric_type=="modeled") {
  table <- data.frame(Number= facils$within$NUM, 
                        Facility=facils$within$propname, 
                        Rivseg= facils$within$riverseg,
                        Locality = facils$within$Locality,
                        Metric_2020 = facils$within[,df$runlabel[1]],
                        Metric_2040 = facils$within[,df$runlabel[2]]
                        ) 
  #names(table)[names(table) == 'Metric'] <- df$runlabel[1]
  
  #----Add rivseg names- - - - - -
   for(i in 1:nrow(table)){ 
    loc_rivseg <- (segs$basin[grep(facils$within$riverseg[i], segs$basin$riverseg),])
    if (nrow(loc_rivseg) != 0) {
      table$rivsegName[i] <- loc_rivseg$name
    } else { # if no matching row was found for the riverseg ID, leave blank but don't break
      table$rivsegName[i] <- ""
      }
  }
   #---- add permitted capacity----
  for (i in 1:nrow(facils$within)){
    systemObj <- RomProperty$new(ds,list(
      featureid = facils$within$featureid[i],
      propcode= "vahydro-1.0"), 
    TRUE)
    permCapac <- RomProperty$new(ds,list(
    featureid = systemObj$pid,
    propname = 'vwp_max_mgy'),
    TRUE)
    table$vwp_max_mgy[i] <- permCapac$propcode  
  }
  #Replace zeros with "no permit"
  table$vwp_max_mgy <-  replace(table$vwp_max_mgy, table$vwp_max_mgy==0, "No Permit")
  #Re-order columns
  table <- table[,c(1:2,4,7,3,8,5,6)]
  #---- change col names for better flextable ---
  colnames(table)[4] <- "River Segment Name"
  colnames(table)[5] <- "River Segment ID"
  colnames(table)[6] <- "Permitted Capacity (mgy)"
  colnames(table)[7] <- paste0('2020 ',metric)
  colnames(table)[8] <- paste0('2040 ',metric)
  }
}
```

# Call Table 
``` {r Call Table Function, echo= False, warning= False}
fn_tablegen(table)
```


-- End Operational RMD --





```{r (Old) Filter Facils/Sources by map_type Extent, warning=FALSE}
## If chunk @ line ~ 400 isn't working, use this 
## filtering MPs or facilities by extent we want, 
facils_all <- facils$all #create temporary df for use in sqldf for ordering

if (map_type == "basin") { #'type' variable will either be: basin, locality, or region 
  for(i in rivseg){. #newly moved into this loop
    if(i==rivseg[1]){
    segs$basin <- fn_extract_basin(segs$all, i)
    }
    if(i!=rivseg[1]){
    segs$basin <- rbind(segs$basin, fn_extract_basin(segs$all, i))
    }
  }
  facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
  facils$all <- facils$all[!is.na(facils$all$Latitude),]
  facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  st_crs(facils$sf) <- 4326 
  segs_basin <- segs$basin
  segs$basin_sp <- process_geom(segs$basin, "geom")
  segs$basin_sf <- st_as_sf(segs$basin_sp)
  st_crs(segs$basin_sf) <- 4326 
  if (metric_type == "modeled") {
    facils$basin <- sqldf("SELECT facils_all.* 
                          FROM facils_all 
                          WHERE riverseg 
                          IN (select segs_basin.riverseg from segs_basin) 
                          AND riverseg IS NOT NULL") # previously: facils$basin <- subset(facils$all, riverseg %in% segs$basin$riverseg & riverseg!="NULL")
    facils$basin <- st_filter(facils$sf, segs$basin_sf)
    coords <- st_coordinates(facils$basin$geometry)
    colnames(coords) <- c("Longitude", "Latitude")
    facils$basin <- st_drop_geometry(facils$basin)
    
  } else if (metric_type == "measured") {
    facils$basin <- st_filter(facils$sf, segs$basin_sf)
    coords <- st_coordinates(facils$basin$geometry)
    colnames(coords) <- c("Longitude", "Latitude")
    facils$basin <- st_drop_geometry(facils$basin)
  }
  facils$basin <- with(facils, sqldf("SELECT * 
                                     FROM basin 
                                     WHERE hydrocode not like 'wsp_%'") )  # Filter out WSP (optional)
  facils_basin <- facils$basin #create temporary df for use in sqldf for ordering
  facils_basin <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_basin.*  
   FROM facils_basin 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC")) #ordering by the metric of interest, descending 
  facils$basin <- facils_basin 
  rm(facils_basin) #removing the ordered data frame since we're finished with it 
  facils$basin$NUM <- seq(1, nrow(facils$basin))
  facils$basin <- cbind(facils$basin, coords)
  facils$within <- facils$basin #generic name for facils within extent to be used by mapping fun 
#  sf_use_s2(FALSE) # switch off Spherical geometry
#  bbox <- st_buffer(st_as_sfc(st_bbox(segs$basin_sf)), .05) #slightly past basin
}
if (map_type == "locality") {
  ## pull locality and geometry out of data frame with the locality parameter given
  locality_sf <- counties$sf[counties$sf$name == locality, ] #if REST IS working
  locality_sp <- process_geom(as.data.frame(locality_sf), "dh_geofield") #for reverse-fill process for map 
  facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
  facils$all <- facils$all[!is.na(facils$all$Latitude),]
  facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  
  st_crs(facils$sf) <- 4326 
  st_crs(locality_sf) <- 4326 
  facils$within <- st_filter(facils$sf, locality_sf) #filter MPs by the extent of the locality
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  sf_use_s2(FALSE)
  segs$basin <- st_filter(segs$sf, locality_sf) #filter basins by locality
  segs$basin <- st_drop_geometry(segs$basin)
  coords <- st_coordinates(facils$within$geometry)
  colnames(coords) <- c("Longitude","Latitude")
  facils_within <- st_drop_geometry(facils$within) #create temporary df for use in sqldf for ordering
  facils_within <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_within.*  
   FROM facils_within 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
  facils$within <- facils_within 
  rm(facils_within) #removing the ordered data frame since we're finished with it 
  facils$within$NUM <- seq(1, nrow(facils$within))
  facils$within <- cbind(facils$within, coords)
  facils$within<- st_as_sf(facils$within, coords = c("Longitude","Latitude"))
  facils$within <- cbind(facils$within, coords)
  st_crs(facils$within) <- 4326
  facils$within <- st_drop_geometry(facils$within)
#  sf_use_s2(FALSE) # switch off Spherical geometry
#  bbox <- st_buffer(st_as_sfc(st_bbox(locality_sf)), .05) #slightly past basin
}
if (map_type == "region") {
  #region geometries stored in region_geom_list under the region name 
  #pull region of interest given in params from list of region geometries 
  region_list <- region_geom_list[names(region_geom_list) == region]
  region_sf <- st_sfc(region_list) #create sf object from the region specified
  region_sfd <- st_as_sf(region_sf) #for region_sp
  segs$region_sf <- region_sfd # for darker outline around region
  st_crs(segs$region_sf) <- 4326
  region_sp <- as_Spatial(region_sfd, cast = FALSE)
  st_crs(region_sf) <- 4326 #set coordinate system for spatial filtering 
  segs_all <- segs$all[-which(segs$all$geom == ""), ] #need to remove rows with empty geometries 
  segs$sp <- process_geom(segs_all, "geom") #takes a few seconds
  rm(segs_all)
  segs$sf <- st_as_sf(segs$sp)
  st_crs(segs$sf) <- 4326
  sf_use_s2(FALSE)
  segs$basin <- st_filter(segs$sf, region_sf) #filter basins by the region
  segs$basin <- st_drop_geometry(segs$basin)
  ## filtering by region:
  facils$all <- facils$all[!is.na(facils$all$Longitude),] #remove rows with missing coords for sf creation
  facils$all <- facils$all[!is.na(facils$all$Latitude),]
  facils$sf <- st_as_sf(facils$all, coords = c("Longitude","Latitude"))
  st_crs(facils$sf) <- 4326 
  facils$within <- st_filter(facils$sf, region_sf) #filter to MPs within the region
  coords <- st_coordinates(facils$within$geometry)
  colnames(coords) <- c("Longitude","Latitude")
  facils_within <- st_drop_geometry(facils$within) #create temporary df for use in sqldf for ordering
  facils_within <- sqldf(paste0( #ordering the data using sqldf 
  "SELECT facils_within.*  
   FROM facils_within 
   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
  )
  facils$within <- facils_within 
  rm(facils_within) #removing the ordered data frame since we're finished with it 
  facils$within$NUM <- seq(1, nrow(facils$within))
  facils$within <- cbind(facils$within, coords)
  facils$within<- st_as_sf(facils$within, coords = c("Longitude","Latitude"))
  facils$within <- cbind(facils$within, coords)
  facils$within <- st_drop_geometry(facils$within)
#  st_crs(facils$within) <- 4326
#  facils_region <- st_filter(facils_sf, region_sf) ## needs to be modified for regions w 2 or more polygons
#  coords <- st_coordinates(facils_region$geometry)
#  colnames(coords) <- c("Longitude","Latitude")
#  facils_region <- cbind(facils_region, coords)
#  facils_region <- st_drop_geometry(facils_region)
#  facils_region <- sqldf(paste0( #ordering the data using sqldf 
#  "SELECT facils_region.*  
#   FROM facils_region 
#   ORDER BY", ' ', df$runlabel[1], ' ', "DESC") #ordering by the metric of interest, descending 
#   )
#  facils_region$NUM <- seq(1, nrow(facils_region))
#  facils_within <- facils_region #facils$within needs to stay as MPs for table generation
#  sf_use_s2(FALSE) # switch off Spherical geometry
#  bbox <- st_buffer(st_as_sfc(st_bbox(region_sf)), .05) #slightly past basin
}
facils$within <- facils$within[,colSums(is.na(facils$within))<nrow(facils$within)] #remove columns with all NAs
rm(facils_all)
```



```{r}
## No longer used, but keeping for now:

#- - - - add 5 yr avg use (MGY) with wd current- PER FACILITY - - -
# for (i in 1:nrow(facils$basin)){
# val <- RomProperty$new(ds,list(
#     featureid= facils$basin$featureid[i],
#     propname= "wd_current_mgy"), 
#   TRUE)
# five_mgy <- val$propvalue
# table$five_mgy[i] <- round(five_mgy,2)
# }
#- - -  5 year avg PER SOURCE - - - 
#what 5 years should we be using 
#why are the numbers sometimes very different
#for (i in 1:nrow(facils$basin)){
#  fiveavg <- mean(na.omit(facils$basin$'2022'[i],facils$basin$'2021'[i],facils$basin$'2020'[i],facils$basin$'2019'[i],facils$basin$'2018'[i], na.rm= TRUE))
#  table$five_mgy_new[i] <- round(fiveavg, 2)
#}
#table$five_mgy_new <- facils$basin$fiveyr_avg_mgy_2

# #- - - -add upstream or downstream - - - removed for now, not priority
# 
# #needs to be adjusted 
# for(i in 1:nrow(facils$basin)){ 
#   if(facils$basin$riverseg[i] == rivseg)
#   {
#     up_down<- "Upstream"
#     table$Upstream_Downstream[i] <- up_down
#   }
#   else if (facils$basin$riverseg[i] != rivseg)
#   {
#     up_down <- "Downstream"
#     table$Upstream_Downstream[i] <- up_down
#   }
# }

# Full join facility model data & facility foundation data
#    facils$all <- with(facils, sqldf("select foundatn.* , mdat.* from foundatn 
#      left outer join mdat
#      on (foundatn.Facility_hydroid = mdat.featureid)
#      UNION
#      select foundatn.* , mdat.* from mdat
#      left outer join foundatn
#      on (foundatn.Facility_hydroid = mdat.featureid)
#      ") ) #facils$all <- merge(x=facils$mdat, y=facils$foundatn, by.x="featureid", by.y="Facility_hydroid", all=TRUE)

#Won't be necessary once new facilities geom csv is integrated
#if (!"Locality" %in% colnames(facils$all)) {
#  propname <- facils$all$propname
#  facils$all <- process_geom(facils$all, "dh_geofield")
#  facils$all <- st_as_sf(facils$all)
#  st_crs(facils$all) <- 4326
#  facil_join <- st_join(facils$all, counties$sf)
#  facils$all <- cbind(propname, facils$all, facil_join$name)
#  names(facils$all)[names(facils$all) == 'facil_join.name'] <- 'Locality'
#  facils$all <- st_drop_geometry(facils$all)
#}
```

```{r}
## Temporary, for savings tables as csvs 
write.table(facilities_df,file = paste0(getwd(),'/facilities_all_geom.csv'), sep = ",", row.names = FALSE) #Write daily csv
```



