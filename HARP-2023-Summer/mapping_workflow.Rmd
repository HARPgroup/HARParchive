---
title: "Workflow for Mapping Facilities"
author: "HARP Analysts"
date: "`r Sys.Date()`"
output: html_document
params:
  rivseg: ["JA4_7280_7340"] #["JL7_7070_0001"] test with bigger data
  model_version: ["vahydro-1.0"]
  runid_list: [ "runid_11","runid_13" ]
  metric: ["wd_mgd"]
  map_name: ["Appomatox_June8"]
---
```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(hydrotools)
library(sp)
library(rgeos)
library(sf)
library(nhdplusTools)
library(ggmap)
library(ggplot2)
library(ggnewscale)   
library(ggsn)
library(ggspatial)
library(ggrepel)
library(nhdplusTools)
library(dplyr)
library(flextable)
library(geosphere)

basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new("http://deq1.bse.vt.edu/d.dh", rest_uname)
ds$get_token(rest_pw)
site <- 'http://deq1.bse.vt.edu/d.dh'

```

```{r UserInputs, echo=FALSE}
rivseg <- params$rivseg
model_version <- params$model_version
runid_list <- params$runid_list
metric <- params$metric
map_name <- params$map_name
```

```{r Establish Functions, echo=FALSE}
# Convert any data frame w/ geometry stored as "character" to "SpatialXxxDataFrame" (Xx_sp)
process_geom <- function(features) {
  for (i in 1:nrow(features)) {
    sp.i <- sp::addAttrToGeom(
      x=readWKT(features[i,]$dh_geofield), 
      y=as.data.frame(as.list(subset(features[i,],select=-c(dh_geofield)))),
      match.ID=TRUE
    )
    if (i == 1) {
      # start with one 
      features_sp <- sp.i
    } else {
      # append
      features_sp <- rbind(features_sp, sp.i)
    }
  }
  return(features_sp)
}
```

```{r Aquire sp Data, echo=FALSE, warning=FALSE, message=FALSE}
# Get all vahydro watershed features
#allsegs <- ds$get('dh_feature', config=list(ftype='vahydro',bundle='watershed'))
#allsegs$riverseg <- str_replace(allsegs$hydrocode, 'vahydrosw_wshed_', '')

#####TEMPORARY allsegs ds$get error work-around#########
localpath <- tempdir()
filename <- paste("vahydro_riversegs_export.csv",sep="")
destfile <- paste(localpath,filename,sep="\\")
download.file(paste(site,"/vahydro_riversegs_export",sep=""), destfile = destfile, method = "libcurl")
allsegs <- read.csv(file=paste(localpath , filename,sep="\\"), header=TRUE, sep=",")
#AllSegList <- substring(RSeg.csv$hydrocode, 17)
allsegs$riverseg <- str_replace(allsegs$hydrocode, 'vahydrosw_wshed_', '')
colnames(allsegs) <- gsub("geom", "dh_geofield", colnames(allsegs))
##############

# Then, extract the basin using fn_extract_basin()
basin_featr <- fn_extract_basin(allsegs, rivseg)
# Convert to sp
basin_sp <- process_geom(basin_featr)

# Get all facilities
df <- data.frame(runid=runid_list, model_version, metric=metric)
#df$runlabel <- paste('WD MGD', df$runid)
for(i in 1:length(runid_list)){
  df$runlabel[i] <- paste("metric_","runid", i, sep="")
}

facil_featr <- om_vahydro_metric_grid( 
  metric=FALSE, runids=df, featureid='all', 
  entity_type='dh_feature', bundle='facility',
  ftype='all', model_version = model_version,
  base_url = "http://deq1.bse.vt.edu/d.dh/entity-model-prop-level-export",
  ds = ds
)

# Filter down to facilities within the basin
facil_in_basin <- sqldf(
  "select a.* from facil_featr as a
   left outer join basin_featr as b
   on (a.riverseg = b.riverseg)
  where b.riverseg is not null 
  "
)
# filter out WSP entries (optional)
facil_in_basin <- sqldf("select * from facil_in_basin where hydrocode not like 'wsp_%'")

# Get facility coordinates
for(i in 1:nrow(facil_in_basin)){
  facil.i <- RomFeature$new(ds,list(hydroid=facil_in_basin$featureid[i]), TRUE)
  facil_in_basin$dh_geofield[i] <- facil.i$geom
}


#####TEMPORARY#####
for(i in 1:10){
  facil.i <- RomFeature$new(ds,list(hydroid=facil_featr$featureid[i]), TRUE)
  facil_featr$dh_geofield[i] <- facil.i$geom
}

manor_golf <- RomFeature$new(ds,list(hydroid='90467'), TRUE)
##########

# Convert to sp
facil_sp <- process_geom(facil_in_basin)

# Get County fips
fips_filename <- paste("vahydro_usafips_export.csv",sep="")
fips_destfile <- paste(tempdir(),fips_filename,sep="\\")
download.file(paste(site,"usafips_geom_export",sep="//"), destfile = fips_destfile, method = "libcurl")
fips.csv <- read.csv(file=paste(tempdir() , fips_filename,sep="\\"), header=TRUE, sep=",")
fips.csv$dh_geofield <- fips.csv$fips_geom 
fips_sp <- process_geom(fips.csv)

fips.csv$dh_geofield <- fips.csv$fips_centroid
fips_centroid_sp <- process_geom(fips.csv)
```

```{r Process Data for Plotting, echo=FALSE, warning=FALSE, message=FALSE}
#--Polygons Layer--
basin_sf <- st_as_sf(basin_sp) #Convert sp to simple features (sf)
st_crs(basin_sf) <- 4326 #Set coord. reference syst.

fips_sf <- st_as_sf(fips_sp)
st_crs(fips_sf) <- 4326

#--Points Layer--
facil_sf <- st_as_sf(facil_sp)
st_crs(facil_sf) <- 4326
facil_sf <- facil_sf[order(facil_sf$metric_runid1),]

#--Labels & Placement--
rsegs_centroids <- rgeos::gCentroid(basin_sp,byid=TRUE)
#rseg_labels <- data.frame(sf::st_coordinates(st_as_sf(rsegs_centroids)), NAME=basin_sf$riverseg)
rseg_labels <- data.frame(sf::st_coordinates(st_as_sf(rsegs_centroids)), NAME=basin_sf$name)
rseg_labels$NAME <- gsub("\\River.*", "River", rseg_labels$NAME) #remove extraneous descriptors after "River"

fips_labels <- data.frame(sf::st_coordinates(st_as_sf(fips_centroid_sp)), NAME=fips_sf$fips_name)

# gsub to shorten facility names: "[facility_name]:[river_containing_facility]" => "[facility_name]"
facil_sf$propname <- gsub("\\:.*", "", facil_sf$propname) 
facil_labels <- data.frame(sf::st_coordinates(facil_sf), NAME=facil_sf$propname)
facil_labels$NUM <- seq(1, nrow(facil_labels))
  
#--NHD Flowline Data--
sf_use_s2(FALSE) # switch off Spherical geometry (s20
domain <- st_buffer(st_as_sfc(st_bbox(basin_sf)), .2)
nhd  <- plot_nhdplus(bbox = st_bbox(domain), actually_plot = FALSE)

#--Facility-Metric Data--
metric_runid1 <- facil_sf$metric_runid1
metric_runid2 <- facil_sf$metric_runid2
```

```{r, eval = FALSE, message=FALSE}
#### FOR TESTING -- Custom/manual bbox creation 
bbox <- c('-80.0','36.8','-78.5','37.5')
bbox_df <- tibble(V1 = as.numeric(c(bbox[1], bbox[3])), V2 = as.numeric(c(bbox[2], bbox[4])))
bbox_sf <- st_as_sf(bbox_df, coords = c('V1','V2'), crs = 4326)
bbox_ <- st_bbox(bbox_sf)
#ggmap_bbox <- setNames(st_bbox(bbox_), c("left", "bottom", "right", "top")) # need to run this line to use custom bbox 
#nhd  <- plot_nhdplus(bbox = ggmap_bbox, actually_plot = FALSE)
#flowline <- nhd$flowline
```

```{r Labeling major rivers w/ MajorRivers.csv}
### LABELING MAJOR RIVERS
rivs_layer <- fread('https://github.com/HARPgroup/HARParchive/raw/master/GIS_layers/MajorRivers.csv')

riv.centroid.df <-  data.frame(feature=rivs_layer$feature, #creating data frame containing names and centroid locations 
                                GNIS_NAME=rivs_layer$GNIS_NAME,
                                centroid_longitude="",
                                centroid_latitude="",
                                stringsAsFactors=FALSE) 

for (r in 1:length(rivs_layer$feature)) { #adding coordinates to the centroids df for labeling
    riv_geom <- readWKT(rivs_layer$geom[r])
    riv_geom_centroid <- gCentroid(riv_geom,byid=TRUE)
    riv.centroid.df$centroid_longitude[r] <- riv_geom_centroid$x
    riv.centroid.df$centroid_latitude[r] <- riv_geom_centroid$y  
    # riv_geom_clip <- gIntersection(MB_geom, riv_geom)
    riv_geom_clip <- riv_geom
    
    if (is.null(riv_geom_clip) == TRUE) {
      # print("OUT OF MINOR BASIN EXTENT - SKIPPING") 
      next
    }
}
```

```{r, eval = FALSE}
# Labeling major rivers alternate method to using MajorRivers.csv, best method TBD
#streams_order67 <- flowline[flowline$StreamOrde == c(6,7),]
#streams67 <- streams_order67[!streams_order67$gnis_name==' ',] # Need to remove rows without names 
#streams67 <- streams67[!duplicated(streams67$gnis_id),] #Only want 1 row per stream name 

#stream67.centroid.df <-  data.frame(feature=(1:length(streams67$id)), #creating data frame containing names and centroid locations 
#                                GNIS_NAME=streams67$gnis_name,
#                                centroid_longitude="",
#                                centroid_latitude="",
#                                stringsAsFactors=FALSE) 

#for (r in 1:length(streams67$id)) { #adding coordinates to the centroids df for labeling
#    stream_geom_centroid <- st_centroid(streams67$geometry[r])
#    cent.coords <- as.data.frame(st_coordinates(stream_geom_centroid))
#    stream67.centroid.df$centroid_longitude[r] <- cent.coords$X
#    stream67.centroid.df$centroid_latitude[r] <- cent.coords$Y
#    }
```


```{r, warning=FALSE}
### LABELING SMALLER RIVERS & STREAMS 
# Names are contained within flowline data -- testing with naming by order 4 streams (Major rivers = order 6)
streams_order4 <- flowline[flowline$StreamOrde == 4,]
streams4 <- streams_order4[!streams_order4$gnis_name==' ',] # Need to remove rows without names 
streams4 <- streams4[!duplicated(streams4$gnis_id),] #Only want 1 row per stream name 
shared_rivs <- generics::intersect(streams4$gnis_name, rivs_layer$GNIS_NAME) #finding the rivers which are also classified as major rivers
streams4 <- streams4[!streams4$gnis_name %in% shared_rivs, ] # Removing rows with names matching any in shared rivers list

stream4.centroid.df <-  data.frame(feature=(1:length(streams4$id)), #creating data frame containing names and centroid locations 
                                GNIS_NAME=streams4$gnis_name,
                                centroid_longitude="",
                                centroid_latitude="",
                                stringsAsFactors=FALSE) 

for (r in 1:length(streams4$id)) { #adding coordinates to the centroids df for labeling
    stream_geom_centroid <- st_centroid(st_geometry(streams4$geometry[r]))
    cent.coords <- as.data.frame(st_coordinates(stream_geom_centroid))
    stream4.centroid.df$centroid_longitude[r] <- cent.coords$X
    stream4.centroid.df$centroid_latitude[r] <- cent.coords$Y
    }
```

```{r Don't Ovrlap Labels, warning = TRUE}
## Combining labels & centroids for Major Rivers & smaller Rivers & streams 
riv.centroid.df$class <- 9 # Adding columns to each df for unique labeling 
stream4.centroid.df$class <- 6
labs_bind <- rbind(riv.centroid.df, stream4.centroid.df) # binding data frames together
```

```{r, warning=FALSE}
## Create boundary box based on basin layer with a buffer 
ggmap_bbox <- st_buffer(st_as_sfc(st_bbox(basin_sf)), .05)
ggmap_bbox <- setNames(st_bbox(ggmap_bbox), c("left", "bottom", "right", "top"))
```

```{r}
## Auto-adjusting scalebar
bbox_points <- tibble(long = c(ggmap_bbox[1], ggmap_bbox[3]), lat = c(ggmap_bbox[2], ggmap_bbox[4]))
bbox_sf <- st_as_sf(bbox_points, coords = c('long','lat'), crs = 4326) # for use in data arg within scalebar (optionally)
dist_m <-  distHaversine(bbox_points) #  calculating the geographic distance between corners of the boundary box 
dist_mi <- dist_m / 1609.34 # default unit for output distance is meters , scale bar needs to be in miles
dist <- round((dist_mi/20), digits = 0)
extent <- as.data.frame(bbox_points)
colnames(extent) <- c('x','y')
```

```{r}
## Adjusting zoom AND which flowlines to map based on boundary box size for clean mapping 
if (dist_mi > 500) {
  nhd$flowline_plot <- nhd$flowline[!(nhd$flowline$StreamOrde == 1| nhd$flowline$StreamOrde == 2| nhd$flowline$StreamOrde == 3),]
  zoom = 7
} else if (dist_mi > 300) {
  nhd$flowline_plot <- nhd$flowline[!(nhd$flowline$StreamOrde == 1 | nhd$flowline$StreamOrde == 2),]
  zoom = 8
} else if (dist_mi > 150) {
  nhd$flowline_plot <- nhd$flowline[!nhd$flowline$StreamOrde == 1,]
  zoom = 9
} else {
  nhd$flowline_plot <- nhd$flowline
  zoom = 10
}
```


```{r Create Map Base, echo=FALSE, warning=FALSE, message=FALSE}
basemap <- ggmap::get_stamenmap(maptype = "terrain-background", color="color", bbox = ggmap_bbox, zoom = as.numeric(zoom))
basemap <- ggmap(basemap)
```

```{r, eval = FALSE}
# TESTING for now 
## City locations for labeling -- need to put file in permanent place on github 
setwd(export_path)
cities_csv <- fread("~/Desktop/HARPteam23/uscities.csv") ## reads in cities data, need to change to common location 
cities_va <- cities_csv[cities_csv$state_id == 'VA',] # filters to only cities within VA
#cities_va <- st_as_sf(cities_va, coords = c('lat', 'lng'), crs = 4326) # create sf obj from the given lat longs 
#cities <- st_filter(bbox_sf, cities_va) # selecting only the cities within the bounding box -- doesn't work
```



```{r Generate Map Object, echo=FALSE}
map <- basemap + #ggplot2::
#    geom_sf(data = fips_sf, inherit.aes = FALSE, color = "#0033335F", fill = NA, lwd=1) +
    geom_sf(data = nhd$flowline_plot,inherit.aes = FALSE,color = "skyblue3", fill = NA, mapping = aes(lwd = nhd$flowline_plot$StreamOrde), 
            show.legend = FALSE) + scale_linewidth(range = c(0.4,2)) + # mapping all flowlines with thickness based on stream order
    geom_sf(data = nhd$network_wtbd,inherit.aes = FALSE,color = "cornflowerblue", fill = NA, size = 1) +
    geom_sf(data = nhd$off_network_wtbd,inherit.aes = FALSE,color = "cornflowerblue", fill = NA, size = 1) +
#    geom_sf(data = basin_sf, inherit.aes = FALSE, color = "#002289", fill = "#0022974C", lwd=1) +
    #geom_sf(data = facil_sf, inherit.aes = FALSE, color = "white", fill = "black", size = 10, pch = 21) +
  
  # 2020 MGD
#      geom_point(data = facil_labels, aes(X, Y, size=metric_runid1, alpha=metric_runid1), 
               #alpha = .7, 
#               col="yellow", shape = 19, stroke = 0.75) +
#      scale_size(range = c(10,35), 
#                 breaks = c(0, metric_runid1[metric_runid1!=0]),
#                 labels = round(c(0, metric_runid1[metric_runid1!=0]), digits = 3),
                 #guide = guide_legend(title = paste(metric, runid_list[1], sep="_"))
#                 name = paste(metric, runid_list[1], sep="_")
#                 ) + #NOTE: the two scales need identical "name" and "labels" to become one simultaneous legend
#      scale_alpha(range = c(0.5, 0.95),
#                 breaks = c(0, metric_runid1[metric_runid1!=0]),
#                 labels = round(c(0, metric_runid1[metric_runid1!=0]), digits = 3),
                 #guide = FALSE
#                 name = paste(metric, runid_list[1], sep="_")
#                 ) +
    # 2040 MGD
    #new_scale("size") + new_scale("color") + new_scale("alpha") +
    #geom_point(data = facil_labels,aes(X, Y, size=metric_runid2, alpha=metric_runid2), 
    #           #alpha = .5, 
    #           col="red", shape = 19, stroke = 0) +
    #  scale_size(range = c(15,40), 
    #             breaks = c(0, metric_runid2[metric_runid2!=0]),
    #             labels = c(0, metric_runid2[metric_runid2!=0]),
    #             guide = guide_legend(title = paste(metric, runid_list[2], sep="_"))
    #             ) +
    #   scale_alpha(range = c(0.35, 0.8),
    #             breaks = c(0, metric_runid1[metric_runid1!=0]),
    #             labels = c(0, metric_runid1[metric_runid1!=0]),
    #             guide = FALSE
    #             ) +

    theme(text = element_text(size = 30),axis.title.x=element_blank(),axis.title.y=element_blank()) +
    
    # plot labels
#    geom_label(data = rseg_labels, aes(X, Y, label = NAME), colour = "#002269", fill=NA, size=7,
#               label.size=0, label.r= unit(0.3, "mm")) +
#    geom_label(data = fips_labels, aes(X, Y, label = NAME), colour = "#003333", fill= NA, size=9, 
#               label.size=0, label.r= unit(0.3, "mm")) +
##    geom_text(data = facil_labels, aes(X, Y, label = NUM), colour = "black", size = 7) +
  #  geom_label(data = facil_labels, aes(X, Y, label = NUM), colour = "black", size = 10, 
     #          nudge_x = -0.01, nudge_y = 0.01) +
    geom_text_repel(data = labs_bind, aes(x = as.numeric(centroid_longitude), y = as.numeric(centroid_latitude), 
                  group = 1, label = GNIS_NAME, size = class), color = "dodgerblue4", show.legend = FALSE) + 
                  scale_size(range = c(6,10)) + #labeling both major rivers and smaller rivers/streams
        geom_point(data = cities_va, aes(x = as.numeric(lng), y = as.numeric(lat)), color = "black", size = 2) + # points for cities
          geom_text_repel(data = cities_va, aes(x = as.numeric(lng), y = as.numeric(lat), label = city), color = 'black', size = 4) + #label cities
    # Original scalebar
#    ggsn::scalebar(data = basin_sf, location = 'bottomleft', dist = dist, dist_unit = 'mi',  # dist variable scaled based on size of bbox 
#                   transform = TRUE, model = 'WGS84',st.bottom=FALSE, st.size=12 ) +
    # north arrow
    ggspatial::annotation_north_arrow(which_north = "grid", location = "tr",
                                      height = unit(4, "cm"),width = unit(3, "cm"), 
                                      style = north_arrow_orienteering(text_size = 35)
                                      ) +
  #### Adjustable Scale Bar Using Joey's anchoring method 
    ggsn::scalebar(data = bbox_sf, location = 'bottomleft', dist = dist, dist_unit = 'mi', 
                                transform = TRUE, model = 'WGS84',st.bottom=FALSE, 
                                st.size = 9,
                                anchor = c(
                                  x = (((extent$x[2] - extent$x[1])/3)+extent$x[1])-0.45,
                                  y = extent$y[1]+(extent$y[1])*0.001
                                ))
```

```{r Save Map.png, echo=FALSE}
ggsave(
  filename = paste(export_path, map_name, '.5',".png", sep=""),
  plot = map,
  width = 25,
  height = 20
  )
```

# Pulling All Regions/Counties
```{r Pulling all Regions/Counties, warning=FALSE, echo=TRUE, message=FALSE}
all_counties <- RomFeature$new(ds,list(bundle='usafips'),TRUE)
counties.df <- cbind(all_counties[["name"]], all_counties[["hydrocode"]])
  colnames(counties.df) <- c("County", "hydrocode_fips")

all_regions <- RomFeature$new(ds,list(ftype= 'wsp_plan_region'),TRUE)
regions.df <- cbind(all_regions[["name"]], all_regions[["hydrocode"]])
  colnames(regions.df) <- c("Region", "hydrocode")
```

#Create table for map
```{r Create table w/ more facility info, echo= FALSE}

#base table with facility name and number(related to map)
tableData <- data.frame(Facility=facil_in_basin$propname, NUM=seq(1, nrow(facil_in_basin)), Rivseg= facil_in_basin$riverseg) #need to fix numbers so they coordinate with mapping numbers, right now it just makes a new set 

#add locations(locality or subwatershed)
for(i in 1:nrow(tableData)){ 
    loc_basin <- (basin_featr[grep(facil_in_basin$riverseg[i], basin_featr$riverseg),])
    tableData$Location_Basin[i] <- loc_basin$name
}

#loc_basin <- (basin_featr[grep(facil_in_basin$riverseg[1], basin_featr$riverseg),])

 # for (i in seq_along(tableData)) {
  #  tableData$Rivseg[[i]][   tableData$Rivseg[[i]] %in% basin_featr$riverseg] <- basin_featr$name
#}

#add source(river name?)

#add type(GW or SW)

# gw <- RomFeature$new(ds,list(
#     ftype= "gw2_private", #gw specifications on some but no sw specifications, whats what?
#     bundle= "facility"), 
#   TRUE)
# 
# municipal_facil.df <- data.frame(cbind(municipal_facilities[["name"]], 
#                             municipal_facilities[["hydrocode"]],
#                             municipal_facilities[["geom"]]))
#   colnames(municipal_facil.df) <- c("Municipal Facility", "hydrocode", "geom")
  


#add upstream or downstream- this works just need to adjust numbers(see above)
for(i in 1:nrow(facil_in_basin)){ 
  if(facil_in_basin$riverseg[i] == rivseg)
  {
    up_down<- "Upstream"
    tableData$Upstream_Downstream[i] <- up_down
  }
  else if (facil_in_basin$riverseg[i] != rivseg)
  {
    up_down <- "Downstream"
    tableData$Upstream_Downstream[i] <- up_down
  }
}
  

  
#add permitted capacity

#add 5 yr avg use(MGY)

library(flextable)
set_flextable_defaults(
  font.size = 10, theme_fun = theme_vanilla,
  padding = 6,
  background.color = "#009999")
table <- flextable(tableData)
table
```

```{r}
table <- qflextable(facil_labels[,c("NUM", "NAME")])
```

```{r Joey's Scale Bar, eval=FALSE, echo=FALSE}
base_scale <-  ggsn::scalebar(data = bbDF, location = 'bottomleft', dist = 25, dist_unit = 'mi', 
                                transform = TRUE, model = 'WGS84',st.bottom=FALSE, 
                                st.size = 3, st.dist = 0.03,
                                anchor = c(
                                  x = (((extent$x[2] - extent$x[1])/2)+extent$x[1])-0.45,
                                  y = extent$y[1]+(extent$y[1])*0.001
                                ))
```

```{r Shape Files in R, echo=FALSE, eval=FALSE}
#minor_basins <- fread('https://raw.githubusercontent.com/HARPgroup/HARParchive/master/GIS_layers/MinorBasins.csv')
#James <- minor_basins[grep("\\James.*", minor_basins$name),]


setwd(wd)
majorR <- read_sf(dsn = "HARParchive/GIS_layers/MajorReservoirs", layer = "MajorReservoirs")
droughtReg <- read_sf(dsn = "HARParchive/GIS_layers/DroughtEvaluationRegions", layer = "DroughtEvaluationRegions")
majorRivs <- read_sf(dsn = "HARParchive/GIS_layers/MajorRivers", layer = "MajorRivers")
  majorRivs <- st_zm(majorRivs) #ZM data not supported --> drop the M

ggmap_bbox <- st_buffer(st_as_sfc(st_bbox(droughtReg)), .05)
ggmap_bbox <- setNames(st_bbox(ggmap_bbox), c("left", "bottom", "right", "top"))
basemap <- ggmap::get_stamenmap(maptype = "terrain", color="color", bbox = ggmap_bbox, zoom = 9)
basemap <- ggmap(basemap)


sf_use_s2(FALSE) # switch off Spherical geometry (s20)
nhd  <- plot_nhdplus(bbox = st_bbox(ggmap_bbox), actually_plot = FALSE)


VA <- basemap +
  geom_sf(data = droughtReg, inherit.aes = FALSE, color = "#003333", fill = NA, lwd=1) +
  geom_sf(data = majorR, inherit.aes = FALSE, color = "red", fill = NA, lwd=0.3) +
  geom_sf(data = majorRivs, inherit.aes = FALSE, color = "blue", fill = NA, lwd=0.3)

VA


regions <- RomFeature$new(ds,list(
  ftype='wsp_plan_region', 
  bundle='landunit'),
  TRUE)

```


